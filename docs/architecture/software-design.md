# 软件设计

3个层次：辨别什么是好的设计，提升专业素养，以及掌握卓越开发实践。

一个根本挑战、两大核心价值、三大设计原则和对应的软件设计实践

![](../images/design-directory.png)

一个根本挑战指的是软件与生俱来的复杂性，两大核心价值指的是软件开发的当前业务价值（满足业务需求）和长期资产价值（复用和演进），三大设计原则指的是分而治之、持续演进和质量内建。一个根本挑战指的是软件与生俱来的复杂性，两大核心价值指的是软件开发的当前业务价值（满足业务需求）和长期资产价值（复用和演进），三大设计原则指的是分而治之、持续演进和质量内建。

## 识别优秀设计

### 优质代码的外部特征

![](../images/outside-pattern.png)

#### 实现了期望的功能

用户真正需要的和用户描述的往往并不一致，经过层层加工，信息更是进一步失真。

##### 为什么需求问题如此普遍

- 软件解决的是现实世界的复杂问题 

    > 现实世界有多复杂，软件就有可能多复杂。

    要真正产出有价值的软件，需要关注以下两个重要的方面。
    - 加快认知的过程。
    - 增加设计的弹性，在出现问题时能较快调整。
- 高质量沟通是困难的，也是容易被忽略的
    
    > 在现实世界中，每一次信息传递都意味着一次信息损耗。

##### 解决问题的方向

优秀的开发者会关注自己开发的软件的真正价值，而不只是盲目地接收到手的需求。实践表明，开发者的积极投入是高效理解需求、提升设计质量的关键.

- 结构化的探索（需求分析金字塔）

- 注重沟通

- 强调设计契约

    契约的本质是信息明确、以终为始。只有尽可能地强调明确，才可以发现需求的模糊性，提升在早期发现问题的概率

- 做到演进式设计

    > 好的设计应该是柔性的。    

#### 缺陷尽量少

##### 关于软件缺陷的两个事实

- 缺陷不可能完全避免

- 尽量早地发现缺陷

    > 理论基础是缺陷成本递增原理。

##### 解决问题的方向

- 缩短缺陷的发现周期（测试前置）
- 降低缺陷的发现成本和修复成本（全面的自动化测试、更小的迭代）
- 缩小缺陷的影响面

    > 通过把软件划分为更合理的设计单元，定义清楚设计单元之间的依赖、接口和契约，并采取契约式设计等手段

#### 易于理解

代码在其生命周期中被阅读的时间，是编写代码所用时间的10倍

##### 为什么代码难以理解

- 不良代码充斥着细节和意外
- 范式或概念不一致

##### 提升代码可理解性的关键

降低代码的复杂性，是提升代码可理解性的关键

一个程序员在编写代码的时候，是否思考过别人会如何阅读这段代码？又应该如何做，才能尽可能减少别人理解这段代码的成本？

#### 易于演进

> 演进是软件的最本质特征

##### 为演进而设计

- 良好的设计结构

    正交设计是增强代码演进能力最重要的手段，通过 SOLID 原则有助于形成正交设计

    ![](../images/orthogonal-design.png ":size=50%")

- 自动化测试
- 简单设计

    今天你所做的任何决定，都是软件未来变化的约束。

#### 易于复用

##### 设计质量决定了复用能力

##### 提升复用能力的手段

- 选择合适的复用粒度

    > 复用粒度越大，复用价值也就越大，不过复用的机会往往更小

    业务模块的复用已经有了更好的理论基础，而且经过了实践的检验。这就是以领域为中心的设计

    > 代码的“复制 - 粘贴”不是复用，它是复用的反面

- 清晰的设计职责和设计契约

    可靠的复用必须满足两个条件。第一，被复用模块的职责必须清晰，这样别人才可以知道该不该复用、能不能复用。第二，被复用模块的实际行为必须和承诺的职责相一致，这样才能被可靠地复用

- 很好地管理依赖

    尽量依赖抽象的接口而不是具体的实现、依赖设计小而聚焦的接口而不是大而全的接口

### 优质代码的内在特征

![](../images/inside-pattern.png)

#### 一致的编码风格

##### 需要一致的编码风格

不一致的编码风格会对代码的可理解性、可维护性产生非常大的影响。此外，从心理角度讲，风格不一致的代码会给人一种“敷衍”的感觉，使他们很难静下心来精心打磨设计。

##### 通过编程规范约束编码风格

要想有效实施编程规范，需要注意如下3个方面。
- 有成文的编程规范。
- 团队成员对编程规范的约定有深刻的理解。
- 编程规范是团队资产的一部分，会被刻意关注并持续演进。

> 编码规范的约定可以参考《阿里巴巴Java开发手册》

编程规范并不是一堆刻板的条文，而是最佳经验的总结。开发者除了要遵循编程规范，更要懂得编程规范背后的逻辑。

##### 编程规范也要持续演进

##### 通过代码评审和结对编程统一编码风格

#### 有意义的命名

##### 命名应该反映业务概念

为命名犯难不应该在编程的时候才发生，它应该被前移到问题分析阶段。命名困难的本质，是没有对业务概念建立正确的理解

##### 避免从开发视角命名业务概念

从业务视角而不是开发视角命名代码，是程序员努力的方向

##### 面向设计意图进行命名优化

#### 简洁的行为实现

##### 代码元素要尽量简短

代码元素包括方法、类等

设定一个代码行数量的警戒值有助于编写更高质量的代码。之所以会有过长的方法，很多时候是因为在一个方法中做了太多事情。有意识地减少代码行（如抽取一个新方法）有助于发现不够内聚的设计，或者抽象层次不足等问

##### 代码的表达要清晰，抽象层次要一致

在编码中做到“一致的抽象层次”并不是太困难，核心是要采用正确的编码顺序，也就是由外而内的设计和实现方法

##### 方法的实现复杂度要尽量低

比如圈复杂度要低

#### 高内聚和低耦合的结构

模块化是提升代码可理解性、可演进性、可复用性的关键。

从设计层面看，模块化分解的最高指导原则是高内聚，模块间协作的最高指导原则是低耦合。

##### 高内聚

高内聚描述了一个代码元素边界内内容的紧密程度。高内聚意味着以下两点。

> 代码元素视划分粒度的不同而不同，如子系统、模块、类、方法等。

- 凡是紧密相关的东西，都应该放在一起。
- 凡是被放在一起的东西，都是紧密相关的。

![](../images/high-cluster.png ":size=40%")

##### 低耦合

> 内聚反映了设计单元内部的相关性，耦合则是设计单元之间相关性的表征

如果两个设计单元之间存在某种关系，使得当一个设计单元发生变化或者出现故障时，另外一个设计单元也会受到影响，那我们就说这二者之间存在耦合。

内聚和耦合是彼此影响的两个因素。耦合不可避免.过度耦合是软件设计不稳定、不健壮的根源。

> 避免过度耦合的设计

一般来说，管理好了依赖，也就解决了大多数耦合问题。

![](../images/design-dependency.png ":size=40%")

1. 循环依赖造成紧耦合。循环依赖往往意味着设计不合理，或者依赖粒度过大。（切割依赖）
2. 依赖层级越深，耦合越紧。（通过依赖倒置断开链式依赖，需求方接口）
3. 依赖范围越广，耦合越严重。依赖范围过大，往往也和设计单元承担的职责过多有关。
4. 全局依赖和隐式依赖让耦合难以管理。
    - L 是全局变量。要避免这种耦合
    - L 是外部模块，封装 L
    - L 是隐含的知识（比如重复的代码）
    - L是一个稳定的接口时，J和K之间没有耦合关系
5. 对内部状态和数据的依赖是严重的耦合。内容耦合。在实际项目中常见的设计反模式，如Smart UI 和贫血模型，都是封装不足导致的内容耦合的结果。针对这种问题，最行之有效的做法是：除了纯粹的数据类，都应该尽量少暴露getter/setter方法。

耦合不局限于代码层面，它可以发生在设计的任何粒度上。例如，如果两个系统之间是通过一组API定义进行通信，那这两个系统之间就基于这组API形成了耦合，当你开发的系统使用了某种第三方框架，或者使用了某种消息通信的基础设施时，同时也在你开发的系统和该第三方框架以及消息通信基础设施之间建立了耦合。框架、通信基础设施或者API的变化都会影响依赖这些内容的模块。

#### 没有重复

重复是一种特殊的耦合。

DRY 原则

有句话叫“习惯成自然”，一旦某种编码风格形成习惯，久而久之，也就没人觉得这种重复是一种问题了。

无论重复是否真正有害，关注代码中的重复都能带来有价值的收益。最大的收益就是启发程序员注意关注点分离。

#### 没有多余的设计

##### 避免刻板地遵循某种设计范例

实际项目中常见的是滥用 IoP（面向接口编程）

IoP的本质是定义和实现的分离。定义指的是契约的定义，用接口承载。由于实现更容易变化也更难管。

应用IoP是一种基于投资回报的理性决策。

所有的设计范式，本身都是为了解决某个问题，它的权衡点在于投资回报。如果发现投资回报不合理，这时候就要做到“如无必要，勿增实体”，果断地把不该存在的设计删除。

##### 及时删除已经不再有用的代码

##### 避免为不可预见的未来编写代码

面向不确定的未来，最好的方法是反脆弱。

真正反脆弱的代码，是那些高内聚、低耦合，和业务的本质概念关联紧密、对应良好的代码。当然了，还应该具备良好的自动化测试。

#### 具备自动化测试

##### 保障功能正确

测试的原始目的就是保障功能正确

##### 提升代码可理解性

用测试作为文档的一个特别大的优势是它不会过时。

##### 保障软件系统的持续演进

##### 用契约和资产的观点看待自动化测试

测试的本质绝不仅是“测试”，它更本质的属性是“契约.

## 专业篇 建立扎实功底

### 高质量的需求

![](../images/require.png ":size=50%")

实践一再证明：在一个项目中，如果程序员没有积极投入到需求活动中，而只是被动地接收需求进行开发，那么往往会错漏百出，即使产品经理或需求分析师的能力很强，也无法改变这个结果。

> 是程序员的理解，而不是产品经理的设计，成为系统最后的功能。

#### 用结构化的方法分析需求

需求分析的本质是探索和发现。同时，沟通和确认是需求分析活动中的重要环节

##### 需求工程的三大活动

- 需求获取：正确地捕获业务方的诉求，对应达到的结果建立正确的预期。
    > 再小的需求也必然有期望达到的业务目标或者要解决的具体问题。
- 需求分析和定义：把业务方的诉求成功转换为对软件系统的需求，并进行清晰的表述。
    > 需求分析和定义是生成解决方案的过程：为了解决特定的问题，系统应该提供什么功能？这些功能包含哪些操作步骤？有哪些业务规则？
- 需求澄清和确认：让相关涉众（如开发人员和测试人员）都正确地理解需求，并达成一致。
    > 需求澄清和确认的核心挑战是细节。

##### 探索和发现用户的真正需求

需求分析的核心是探索和发现：通过持续探索，发现并确立真正的业务目标，从而设计出真正合理的方案，包括系统需求、操作步骤和业务规则等

##### 需求分析金字塔

![](../images/require-pyramid.png ":size=30%")

- 不断质疑，澄清业务目标

    为什么要做这个功能？如果不做这个功能，又会怎样？

    通过对业务目标进行质疑和确认，业务分析人员经常会发现业务目标中存在未澄清或者不合理的部分

- 探索业务流程，定义系统功能

    这一步的关键是“探索”，而不是“描述”

    系统功能就是业务流程中那些和软件系统有关的功能。

- 设计操作步骤，澄清业务规则

##### 共创、沟通和共识是需求分析活动成功的关键

- 用文档记录结果，不要用文档作为驱动

    尽可能早地引入需求沟通，进行群体性的共创活动

- 在协作空间讨论和完善需求

- 最大化发现能力，不畏惧需求变化

#### 定义业务目标

##### 目标要反映关键利益方的诉求

对同一个系统而言，不同的核心诉求对应的功能设计以及需求优先级可能是完全不同的。

在讨论业务目标的过程中，常常会出现下列问题。
- 为什么要做这个产品（或者功能）？要达到什么样的业务目标？
- 做出了这个产品（或者功能），期望的业务目标能达成吗？不做的话，可以通过其他途径达到业务目标吗？
- 谁将从这个产品（或者功能）中受益？又有谁可能会受到影响？

解决不同的功能需求能够达到相同的业务目标，需求开发仅仅是达到业务目标的手段。这一点在开发活动中务必注意。

#### 探索业务流程，定义系统功能

从业务目标到系统需求并不是一蹴而就的，联系它们的纽带是业务流程。

在开始定义系统功能前，先把业务流程定义清楚

##### 表达业务流程的方法

- 注重实效的UML

    UML就是适用于软件世界的统一表示法。与此相对的是线框图。线框图是随意的，在使用时很难达到精确
    
    把UML作为一种表示法，记录或者表达思考和讨论的过程

    把这种以沟通为目的、仅仅使用UML特征的有限子集来建模的方式，称为注重实效的UML。

- 多绘制草图，仅在必要时使用建模工具

- 用带有泳道的活动图表达业务流程

    有好几种UML图都适用于需求建模，这里列举三种。
    - 用例图：表达系统有哪些功能，执行者会使用系统的哪些功能。
    - 顺序图：表达参与者如何彼此交互，完成一个功能或业务。
    - 活动图：表达一个功能或业务设计的活动或流程。

    > 带有泳道的活动图是顺序图和活动图的结合体，最适合来表达业务流程

- 刻意地省略——抓住主要问题

    建模要注重实效。UML有一个非常好的机制——允许刻意地省略。

    在业务流程阶段，要能充分反映关键的业务节点，不要陷入操作细节

##### 积极地挑战业务流程

##### 使用业务事件推演业务流程

经验表明：正向的思考过程往往容易遗漏关键步骤。

EDBA（事件驱动的业务分析）的核心成功要素是：以业务事件为核心、以终为始、逆向思考。

业务事件指的是应该被关心的、具有业务价值的事件。

和事件相对应的是动作，从确定性上说，事件的确定性比动作的确定性更高，它有助于让我们更加关注业务流程的结果。

基于业务事件进行讨论，可以让需求讨论更聚焦、更清晰

> 16字口诀：事件优先，由后向前，关注例外，整理推演。

##### 从业务流程到系统需求

梳理业务流程的最终目的是软件开发，也就是要确定系统需要实现哪些功能.

系统需求是把“软件系统”作为研究对象，定义软件系统应该做什么，确定清晰的输入和输出

> 用例图最适合于表达系统需求

- 系统边界：明确哪些工作是在软件系统内完成的，哪些是在软件系统外完成的。用例的执行者处在边界外，用例处在边界内。
- 执行者：用例的发起者，经常是业务角色。涉及多系统交互时，执行者也有可能是外部系统。如果涉及定时任务，那么也可以把定时器作为一个特殊的执行者。
- 系统用例：执行者在系统边界上对系统进行的操作。
- 用例图：表达执行者、系统用例、系统边界之间关系的UML图。

业务流程的关注点是业务，系统用例的关注点则要低一个层级，它关注系统

在实际分析系统用例时，往往会对业务流程做进一步优化，还会考虑如何组织用例以体现良好的结构。

#### 完善操作步骤，澄清业务规则

##### 发现细节

一般来说，细节包括两个重要部分。

- 操作步骤
- 业务规则（约束）

##### 建立共识

- 所有参与者都对将要做的事情有一致的理解，没有歧义。
- 所有参与者都知道还有哪些问题尚未澄清。

“刻意地忽略”意味着大家知道哪些事情是暂时被忽略的，这很重要。

##### 表示法

- 用UML顺序图表示操作步骤
    
    UML顺序图擅长表示多个参与者之间存在互动的操作步骤。

- 用UML活动图表示操作步骤

    UML活动图适用于重点不在交互而在执行者所做动作的场景中，用来表示分支等更高效。

##### 用实例化的方式澄清需求

实例化需求

实例优于抽象

如果能想好怎么测试，那需求应该做成什么样也就变得很清晰了。这就是以终为始的思考方法。

![](../images/require-sample.png ":size=40%")

实例化需求的本质是沟通.在每个迭代开始之前，都组织实例化需求工作坊，就即将开发的需求进行讨论，并写出需求的关键实例.

#####　实例化需求的步骤

- 澄清目标
- 发现场景
- 澄清细节

Given-When-Then模式

当类似的示例比较多时，Given-When-Then模式也可以采用表格的形式来表达。

恰当地使用界面原型。使用界面原型作为补充工具，或者是在业务流程已经基本确定的情况下，再使用界面原型进行需求探索和设计，千万不要把界面原型作为唯一的需求探索工具。

### 领域建模

![](../images/domain-model.png)

对业务的概念、概念间的关系及概念本质的认知，就是领域模型。领域模型是高质量软件开发和持续演进的基础，也是领域驱动设计方法的核心，还是微服务和云原生时代重要的基础概念。

#### 领域模型的概念

不管开发什么系统，不重视对应领域的基本概念和业务知识，都是不行的。

##### 领域模型是什么

领域模型定义了问题空间中的关键概念，以及这些概念之间的关系。

领域模型反映的是认知，认知通过概念以及概念之间的关系表达。

##### 使用 UML 类图表达领域模型

在大多数场景下，UML类图是表达领域模型时的合适选择

UML的类图虽然名字是“类图”，但是这个“类”并不只是软件代码中的“类”，而是“概念”。

- 熟悉常见的概念间关系
    - 关联：关联指两个概念之间存在联系。比如教师和学生
    - 多重性：这是指某个关系对应的两端的概念实体的数量对应关系。比如教师和学生是多对多的关系
    - 聚合和组合：聚合是一种特殊的关联，组合又是一种特殊的聚合。这两者表达的是归属关系或者所有关系。组合关系比聚合关系还要紧密。
    - 泛化：泛化反映了概念的抽象。
    - 依赖：依赖指一个概念和另外一个概念有关。“有关”是一种比“关联”弱得多的关系
- 多视图和刻意忽略
    图、表、文本等都只是一种表达形式，它们提供的是一种视图，而非领域模型本身。因此，既不可能，也不需要使用一个视图面面俱到地反映业务概念。

    在“领域模型”是一种“业务概念”这个上下文中，方法/操作（面向对象）是开发人员的概念，没有必要在业务分析阶段进行建模。它们不是领域模型的一部分

##### 领域模型反映了认知

- 领域模型沉淀认知
- 领域模型在一定时期内保持稳定
- 领域模型并非一成不变，它会持续“生长”甚至跃迁

##### 建立高质量的领域模型

领域模型反映了关键的业务认知，但是认知并不会凭空建立。

要建立好领域模型，关键是要做好“捕获、辨析、演进”。

- 捕获：指的是能从需求分析和业务表述中，及时捕获可能是业务概念的信息。
- 辨析：业务概念往往具有模糊性。要能清晰地分辨出：这个业务概念表达的是什么？它需要被分解吗？它能够被抽象吗？它和其他业务概念之间是什么关系？
- 演进：人对业务概念的认知不是一蹴而就的，是渐进的。要随时留意，新的业务场景产生了哪些新的业务概念？加入了新的业务概念后，原有的领域模型是否需要调整？

##### 捕获业务概念

名词就是业务概念

##### 辨析业务概念

在捕获到业务概念的那一刻，就立即定义这个概念。如果需要分解，就立即进行业务概念的分解；如果需要抽象，就立即进行业务概念的抽象。

- 定义业务概念
- 分解业务概念
    - 警惕模糊的业务概念带来的问题
    - 及时分解看起来相似、事实上不同的业务概念

##### 抽象业务概念

- 如何抽象取决于特定的业务场景
    - 对抽象最直观的理解，就是分类归纳
    - 事物具有多种不同的抽象视角。

在抽象过程中，要始终思考业务概念所处的上下文，能够有效避免过度抽象。分解和抽象业务概念的能力是需要刻意训练的。

##### 子域

把子域当作了一个重要的战略模式，其核心思想就是按问题域进行分解。

根据子域通用程度的不同，我们把子域进一步划分为核心域、通用域和支撑域。

- 核心域: 核心域和产品的核心业务逻辑相关，决定了产品的核心竞争力，产品的差异性和特殊性体现在这种域中。
- 通用域: 通用域是那些包含在大多数不同类型的产品中的子域。这种域往往没有太多个性化的诉求。
- 支撑域: 支撑域的通用水平尚未达到通用域，也不像核心域那样能决定产品的核心竞争力，但确实是一个完整产品所必须的。

#### 持续演进业务概念

持续演进遵循如下基本步骤。
1. 从需求分析和业务表述中捕获业务概念，并对其进行抽象。
2. 把业务概念及时归置到领域模型中，然后利用领域模型中的业务概念，去描述需求。
3. 如此循环往复，在持续探索需求的同时，持续精化领域模型。

#### 用领域模型指导软件开发

##### 领域模型和统一语言

统一语言具有以下几个优点

- 提升沟通效率
- 确保及时更新
- 降低表示差距

任何出现在需求描述中的业务概念，都必须出现在领域模型中

##### 避免领域建模的常见误区

- 避免从开发视角进行领域建模
- 领域模型不是数据库模型。不要站在开发视角定义领域模型。
- 避免建立庞大的领域模型
    - 领域越大，越不利于建立认知和共识。我们应该把大领域划分为小领域，然后逐个建立这些小领域的领域模型。那种“整整一面墙”的领域模型，是非常不可取的
    - 把大领域拆分为小的子域，并为每个子域分别建模。
- 避免只是重视文档，而忽略交流和共识
    - 领域模型的核心在于建立共同的认知，也就是共识。
    - 领域模型一定要显式化

### 设计分解和责任分配

![](../images/design-decompose2.png ":size=50%")

软件设计的本质是设计分解和责任分配，也就是通常所说的模块化。

#### 通过分而治之管理复杂性

> 分而治之是控制复杂性的有效手段。

##### 组织的复杂性类比

在软件设计和一切复杂的场景中，“元素”“责任”和“协作”都是非常有效的思考策略和组织策略。

架构是系统在其环境中的基本概念或属性，体现为元素、关系以及设计和演进的原则。

- 元素：反映了分解
- 责任：反映了职责分配
- 协作：反映了分解后的元素之间的协同

元素、责任和协作是分解的结果，

软件设计的分解结果是软件系统模块化了。

##### 软件设计的自相似性——分形

![](../images/design-decompose.png ":size=40%")

##### 使用UML表达软件设计的分解结果

- UML类图    
    ![](../images/uml-class.png)
    > `<<subsystem>>` 符号，这种符号叫作构造型(sterotype)，也就是对某种具体设计元素的类型修饰。
- UML包图
    - UML包图更加强调设计元素的容器属性，UML类图更加强调设计元素的属性和职责。从这个角度，也可以把UML包图看作UML类图的一种特殊构造型。
- UML交互图
    - UML的顺序图、通信图、带有泳道的活动图

##### 使用代码结构表达软件设计的分解结果

在类层次的设计元素，只有少部分比较困难或创新的需要使用UML图来构思或讨论，大多数时候是可以直接使用代码结构表达的。代码结构是表达设计分解的有效元素。

#### 架构分解的原则与模式

##### 原则1：优先按照问题领域分解

两个基本入手点：横切（按照设计层次分解）和纵切（按照问题领域分解）

![](../images/arch-decompose.png)

对于中大规模的系统来说，如果按照横切方式分解，那么会遇到一些困难，应该优先选择纵切的方式，也就是按照问题领域分解。原因有以下三个
- 高内聚和低耦合。属于同一个问题领域的模块之间的联系更为紧密
- 易于复用
- 避免混乱

##### 原则2：面向质量属性定义架构策略

![](../images/arch-dfx.png)

前6列可以从外部感知，称它们为外部质量属性；后2列仅可以从软件组织内部感知，称它们为内部质量属性。

##### 原则3：选用合适的架构风格和模式

风格和模式是既往设计经验的结晶。

在实践中，没有必要过度区分风格和模式的差异。例如，既可以把分层看作一种架构风格，也可以把分层看作一种常见的架构模式。

#### 正确使用语言特性

##### 封装、继承和多态

软件设计的角度看，那么更重要的策略是“分解”“组合”“委托”“抽象”这样的设计概念，封装、继承和多态是在语言层面上对这些设计思想的实现。

##### 用继承和多态表达抽象

##### 避免误用继承

##### 用里氏替换原则指导继承关系的使用

##### 用委托的方式实现复用

委托是一种非常强大的复用方式。在面向对象的程序设计中，需要复用时应该优先考虑委托，而不是继承。

##### 面向对象的职责视角——抽象、委托和组合

委托和组合是职责分解的两种表达形式。自上而下的职责分解就是委托；自下而上地把若干设计单元联合起来完成一个更大的职责，就是组合。

抽象的本质就是，从职责视角看，若干设计单元可以等价。

#### 关注点分离

##### 用单一职责原则指导关注点分离

要检验关注点分离得是否清晰，最好的方法是用变化来检验。

单一职责原则： 一个类应该只有一个变化的原因。

##### 如何判断关注点分离和过度设计

一般来说，只要能识别出不同的关注点，新代码就不会比原有代码复杂。

设计是否合理的终极评判标准是总体收益是否得到了最大化，要同时考量成本和效率。新增的抽象会增加额外的复杂度

##### 用开放——封闭原则检验关注点分离

开放 - 封闭原则：如果一个设计在每次实现新的需求时都必须打开既有的代码，那它就不是一个好的设计

开放 - 封闭原则是一种检验手段，可以检验产出的设计是否高质量。

#### 设计模式

##### 模式的价值

模式最重要的价值是提升思考的粒度

模式还有助于便捷地交流

##### 用设计模式指导软件设计

许多设计模式是对关注点分离和抽象的应用

- Iterator模式是对“遍历执行”这个活动的抽象，也是“如何遍历”和“遍历后做什么”这两个关注点的分离。
- Strategy模式是对具体操作行为的抽象。
- Composite模式是对整体和部分的分离，也是对事物自相似性的抽象。
- Decorator模式是对核心职责和附加职责的分离。

##### 在重构中涌现模式

避免生搬硬套设计模式的核心要诀是：仅在需要的时候才进行关注点分离和概念的抽象。

重构和设计模式之间存在彼此促进的关系。首先，设计模式为重构过程提供了有效的牵引。其次，重构是应用设计模式的最好时机

### 依赖、接口和契约

## 卓越篇 实现高效编码

### 用测试描述需求和契约

### 用领域模型指导实现

### 由外而内的设计

### 设计指令贯穿始终

### 让设计持续演进

### 精益思想和高效编程


