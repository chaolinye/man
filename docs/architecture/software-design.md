# 软件设计

3个层次：辨别什么是好的设计，提升专业素养，以及掌握卓越开发实践。

一个根本挑战、两大核心价值、三大设计原则和对应的软件设计实践

![](../images/design-directory.png)

一个根本挑战指的是软件与生俱来的复杂性，两大核心价值指的是软件开发的当前业务价值（满足业务需求）和长期资产价值（复用和演进），三大设计原则指的是分而治之、持续演进和质量内建。一个根本挑战指的是软件与生俱来的复杂性，两大核心价值指的是软件开发的当前业务价值（满足业务需求）和长期资产价值（复用和演进），三大设计原则指的是分而治之、持续演进和质量内建。

## 识别优秀设计

### 优质代码的外部特征

![](../images/outside-pattern.png)

#### 实现了期望的功能

用户真正需要的和用户描述的往往并不一致，经过层层加工，信息更是进一步失真。

##### 为什么需求问题如此普遍

- 软件解决的是现实世界的复杂问题 

    > 现实世界有多复杂，软件就有可能多复杂。

    要真正产出有价值的软件，需要关注以下两个重要的方面。
    - 加快认知的过程。
    - 增加设计的弹性，在出现问题时能较快调整。
- 高质量沟通是困难的，也是容易被忽略的
    
    > 在现实世界中，每一次信息传递都意味着一次信息损耗。

##### 解决问题的方向

优秀的开发者会关注自己开发的软件的真正价值，而不只是盲目地接收到手的需求。实践表明，开发者的积极投入是高效理解需求、提升设计质量的关键.

- 结构化的探索（需求分析金字塔）

- 注重沟通

- 强调设计契约

    契约的本质是信息明确、以终为始。只有尽可能地强调明确，才可以发现需求的模糊性，提升在早期发现问题的概率

- 做到演进式设计

    > 好的设计应该是柔性的。    

#### 缺陷尽量少

##### 关于软件缺陷的两个事实

- 缺陷不可能完全避免

- 尽量早地发现缺陷

    > 理论基础是缺陷成本递增原理。

##### 解决问题的方向

- 缩短缺陷的发现周期（测试前置）
- 降低缺陷的发现成本和修复成本（全面的自动化测试、更小的迭代）
- 缩小缺陷的影响面

    > 通过把软件划分为更合理的设计单元，定义清楚设计单元之间的依赖、接口和契约，并采取契约式设计等手段

#### 易于理解

代码在其生命周期中被阅读的时间，是编写代码所用时间的10倍

##### 为什么代码难以理解

- 不良代码充斥着细节和意外
- 范式或概念不一致

##### 提升代码可理解性的关键

降低代码的复杂性，是提升代码可理解性的关键

一个程序员在编写代码的时候，是否思考过别人会如何阅读这段代码？又应该如何做，才能尽可能减少别人理解这段代码的成本？

#### 易于演进

> 演进是软件的最本质特征

##### 为演进而设计

- 良好的设计结构

    正交设计是增强代码演进能力最重要的手段，通过 SOLID 原则有助于形成正交设计

    ![](../images/orthogonal-design.png ":size=50%")

- 自动化测试
- 简单设计

    今天你所做的任何决定，都是软件未来变化的约束。

#### 易于复用

##### 设计质量决定了复用能力

##### 提升复用能力的手段

- 选择合适的复用粒度

    > 复用粒度越大，复用价值也就越大，不过复用的机会往往更小

    业务模块的复用已经有了更好的理论基础，而且经过了实践的检验。这就是以领域为中心的设计

    > 代码的“复制 - 粘贴”不是复用，它是复用的反面

- 清晰的设计职责和设计契约

    可靠的复用必须满足两个条件。第一，被复用模块的职责必须清晰，这样别人才可以知道该不该复用、能不能复用。第二，被复用模块的实际行为必须和承诺的职责相一致，这样才能被可靠地复用

- 很好地管理依赖

    尽量依赖抽象的接口而不是具体的实现、依赖设计小而聚焦的接口而不是大而全的接口

### 优质代码的内在特征

![](../images/inside-pattern.png)

#### 一致的编码风格

##### 需要一致的编码风格

不一致的编码风格会对代码的可理解性、可维护性产生非常大的影响。此外，从心理角度讲，风格不一致的代码会给人一种“敷衍”的感觉，使他们很难静下心来精心打磨设计。

##### 通过编程规范约束编码风格

要想有效实施编程规范，需要注意如下3个方面。
- 有成文的编程规范。
- 团队成员对编程规范的约定有深刻的理解。
- 编程规范是团队资产的一部分，会被刻意关注并持续演进。

> 编码规范的约定可以参考《阿里巴巴Java开发手册》

编程规范并不是一堆刻板的条文，而是最佳经验的总结。开发者除了要遵循编程规范，更要懂得编程规范背后的逻辑。

##### 编程规范也要持续演进

##### 通过代码评审和结对编程统一编码风格

#### 有意义的命名

##### 命名应该反映业务概念

为命名犯难不应该在编程的时候才发生，它应该被前移到问题分析阶段。命名困难的本质，是没有对业务概念建立正确的理解

##### 避免从开发视角命名业务概念

从业务视角而不是开发视角命名代码，是程序员努力的方向

##### 面向设计意图进行命名优化

#### 简洁的行为实现

##### 代码元素要尽量简短

代码元素包括方法、类等

设定一个代码行数量的警戒值有助于编写更高质量的代码。之所以会有过长的方法，很多时候是因为在一个方法中做了太多事情。有意识地减少代码行（如抽取一个新方法）有助于发现不够内聚的设计，或者抽象层次不足等问

##### 代码的表达要清晰，抽象层次要一致

在编码中做到“一致的抽象层次”并不是太困难，核心是要采用正确的编码顺序，也就是由外而内的设计和实现方法

##### 方法的实现复杂度要尽量低

比如圈复杂度要低

#### 高内聚和低耦合的结构

模块化是提升代码可理解性、可演进性、可复用性的关键。

从设计层面看，模块化分解的最高指导原则是高内聚，模块间协作的最高指导原则是低耦合。

##### 高内聚

高内聚描述了一个代码元素边界内内容的紧密程度。高内聚意味着以下两点。

> 代码元素视划分粒度的不同而不同，如子系统、模块、类、方法等。

- 凡是紧密相关的东西，都应该放在一起。
- 凡是被放在一起的东西，都是紧密相关的。

![](../images/high-cluster.png ":size=40%")

##### 低耦合

> 内聚反映了设计单元内部的相关性，耦合则是设计单元之间相关性的表征

如果两个设计单元之间存在某种关系，使得当一个设计单元发生变化或者出现故障时，另外一个设计单元也会受到影响，那我们就说这二者之间存在耦合。

内聚和耦合是彼此影响的两个因素。耦合不可避免.过度耦合是软件设计不稳定、不健壮的根源。

> 避免过度耦合的设计

一般来说，管理好了依赖，也就解决了大多数耦合问题。

![](../images/design-dependency.png ":size=40%")

1. 循环依赖造成紧耦合。循环依赖往往意味着设计不合理，或者依赖粒度过大。（切割依赖）
2. 依赖层级越深，耦合越紧。（通过依赖倒置断开链式依赖，需求方接口）
3. 依赖范围越广，耦合越严重。依赖范围过大，往往也和设计单元承担的职责过多有关。
4. 全局依赖和隐式依赖让耦合难以管理。
    - L 是全局变量。要避免这种耦合
    - L 是外部模块，封装 L
    - L 是隐含的知识（比如重复的代码）
    - L是一个稳定的接口时，J和K之间没有耦合关系
5. 对内部状态和数据的依赖是严重的耦合。内容耦合。在实际项目中常见的设计反模式，如Smart UI 和贫血模型，都是封装不足导致的内容耦合的结果。针对这种问题，最行之有效的做法是：除了纯粹的数据类，都应该尽量少暴露getter/setter方法。

耦合不局限于代码层面，它可以发生在设计的任何粒度上。例如，如果两个系统之间是通过一组API定义进行通信，那这两个系统之间就基于这组API形成了耦合，当你开发的系统使用了某种第三方框架，或者使用了某种消息通信的基础设施时，同时也在你开发的系统和该第三方框架以及消息通信基础设施之间建立了耦合。框架、通信基础设施或者API的变化都会影响依赖这些内容的模块。

#### 没有重复

重复是一种特殊的耦合。

DRY 原则

有句话叫“习惯成自然”，一旦某种编码风格形成习惯，久而久之，也就没人觉得这种重复是一种问题了。

无论重复是否真正有害，关注代码中的重复都能带来有价值的收益。最大的收益就是启发程序员注意关注点分离。

#### 没有多余的设计

##### 避免刻板地遵循某种设计范例

实际项目中常见的是滥用 IoP（面向接口编程）

IoP的本质是定义和实现的分离。定义指的是契约的定义，用接口承载。由于实现更容易变化也更难管。

应用IoP是一种基于投资回报的理性决策。

所有的设计范式，本身都是为了解决某个问题，它的权衡点在于投资回报。如果发现投资回报不合理，这时候就要做到“如无必要，勿增实体”，果断地把不该存在的设计删除。

##### 及时删除已经不再有用的代码

##### 避免为不可预见的未来编写代码

面向不确定的未来，最好的方法是反脆弱。

真正反脆弱的代码，是那些高内聚、低耦合，和业务的本质概念关联紧密、对应良好的代码。当然了，还应该具备良好的自动化测试。

#### 具备自动化测试

##### 保障功能正确

测试的原始目的就是保障功能正确

##### 提升代码可理解性

用测试作为文档的一个特别大的优势是它不会过时。

##### 保障软件系统的持续演进

##### 用契约和资产的观点看待自动化测试

测试的本质绝不仅是“测试”，它更本质的属性是“契约.



## 专业篇 建立扎实功底

### 高质量的需求

### 领域建模

### 设计分解和责任分配

### 依赖、接口和契约

## 卓越篇 实现高效编码

### 用测试描述需求和契约

### 用领域模型指导实现

### 由外而内的设计

### 设计指令贯穿始终

### 让设计持续演进

### 精益思想和高效编程


