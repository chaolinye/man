# 软件设计

3个层次：辨别什么是好的设计，提升专业素养，以及掌握卓越开发实践。

一个根本挑战、两大核心价值、三大设计原则和对应的软件设计实践

![](../images/design-directory.png)

一个根本挑战指的是软件与生俱来的复杂性，两大核心价值指的是软件开发的当前业务价值（满足业务需求）和长期资产价值（复用和演进），三大设计原则指的是分而治之、持续演进和质量内建。一个根本挑战指的是软件与生俱来的复杂性，两大核心价值指的是软件开发的当前业务价值（满足业务需求）和长期资产价值（复用和演进），三大设计原则指的是分而治之、持续演进和质量内建。

## 识别优秀设计

### 优质代码的外部特征

![](../images/outside-pattern.png)

#### 实现了期望的功能

用户真正需要的和用户描述的往往并不一致，经过层层加工，信息更是进一步失真。

##### 为什么需求问题如此普遍

- 软件解决的是现实世界的复杂问题 

    > 现实世界有多复杂，软件就有可能多复杂。

    要真正产出有价值的软件，需要关注以下两个重要的方面。
    - 加快认知的过程。
    - 增加设计的弹性，在出现问题时能较快调整。
- 高质量沟通是困难的，也是容易被忽略的
    
    > 在现实世界中，每一次信息传递都意味着一次信息损耗。

##### 解决问题的方向

优秀的开发者会关注自己开发的软件的真正价值，而不只是盲目地接收到手的需求。实践表明，开发者的积极投入是高效理解需求、提升设计质量的关键.

- 结构化的探索（需求分析金字塔）

- 注重沟通

- 强调设计契约

    契约的本质是信息明确、以终为始。只有尽可能地强调明确，才可以发现需求的模糊性，提升在早期发现问题的概率

- 做到演进式设计

    > 好的设计应该是柔性的。    

#### 缺陷尽量少

##### 关于软件缺陷的两个事实

- 缺陷不可能完全避免

- 尽量早地发现缺陷

    > 理论基础是缺陷成本递增原理。

##### 解决问题的方向

- 缩短缺陷的发现周期（测试前置）
- 降低缺陷的发现成本和修复成本（全面的自动化测试、更小的迭代）
- 缩小缺陷的影响面

    > 通过把软件划分为更合理的设计单元，定义清楚设计单元之间的依赖、接口和契约，并采取契约式设计等手段

#### 易于理解

代码在其生命周期中被阅读的时间，是编写代码所用时间的10倍

##### 为什么代码难以理解

- 不良代码充斥着细节和意外
- 范式或概念不一致

##### 提升代码可理解性的关键

降低代码的复杂性，是提升代码可理解性的关键

一个程序员在编写代码的时候，是否思考过别人会如何阅读这段代码？又应该如何做，才能尽可能减少别人理解这段代码的成本？

#### 易于演进

> 演进是软件的最本质特征

##### 为演进而设计

- 良好的设计结构

    正交设计是增强代码演进能力最重要的手段，通过 SOLID 原则有助于形成正交设计

    ![](../images/orthogonal-design.png ":size=50%")

- 自动化测试
- 简单设计

    今天你所做的任何决定，都是软件未来变化的约束。

#### 易于复用

##### 设计质量决定了复用能力

##### 提升复用能力的手段

- 选择合适的复用粒度

    > 复用粒度越大，复用价值也就越大，不过复用的机会往往更小

    业务模块的复用已经有了更好的理论基础，而且经过了实践的检验。这就是以领域为中心的设计

    > 代码的“复制 - 粘贴”不是复用，它是复用的反面

- 清晰的设计职责和设计契约

    可靠的复用必须满足两个条件。第一，被复用模块的职责必须清晰，这样别人才可以知道该不该复用、能不能复用。第二，被复用模块的实际行为必须和承诺的职责相一致，这样才能被可靠地复用

- 很好地管理依赖

    尽量依赖抽象的接口而不是具体的实现、依赖设计小而聚焦的接口而不是大而全的接口

### 优质代码的内在特征

![](../images/inside-pattern.png)

#### 一致的编码风格

##### 需要一致的编码风格

不一致的编码风格会对代码的可理解性、可维护性产生非常大的影响。此外，从心理角度讲，风格不一致的代码会给人一种“敷衍”的感觉，使他们很难静下心来精心打磨设计。

##### 通过编程规范约束编码风格

要想有效实施编程规范，需要注意如下3个方面。
- 有成文的编程规范。
- 团队成员对编程规范的约定有深刻的理解。
- 编程规范是团队资产的一部分，会被刻意关注并持续演进。

> 编码规范的约定可以参考《阿里巴巴Java开发手册》

编程规范并不是一堆刻板的条文，而是最佳经验的总结。开发者除了要遵循编程规范，更要懂得编程规范背后的逻辑。

##### 编程规范也要持续演进

##### 通过代码评审和结对编程统一编码风格

#### 有意义的命名

##### 命名应该反映业务概念

为命名犯难不应该在编程的时候才发生，它应该被前移到问题分析阶段。命名困难的本质，是没有对业务概念建立正确的理解

##### 避免从开发视角命名业务概念

从业务视角而不是开发视角命名代码，是程序员努力的方向

##### 面向设计意图进行命名优化

#### 简洁的行为实现

##### 代码元素要尽量简短

代码元素包括方法、类等

设定一个代码行数量的警戒值有助于编写更高质量的代码。之所以会有过长的方法，很多时候是因为在一个方法中做了太多事情。有意识地减少代码行（如抽取一个新方法）有助于发现不够内聚的设计，或者抽象层次不足等问

##### 代码的表达要清晰，抽象层次要一致

在编码中做到“一致的抽象层次”并不是太困难，核心是要采用正确的编码顺序，也就是由外而内的设计和实现方法

##### 方法的实现复杂度要尽量低

比如圈复杂度要低

#### 高内聚和低耦合的结构

模块化是提升代码可理解性、可演进性、可复用性的关键。

从设计层面看，模块化分解的最高指导原则是高内聚，模块间协作的最高指导原则是低耦合。

##### 高内聚

高内聚描述了一个代码元素边界内内容的紧密程度。高内聚意味着以下两点。

> 代码元素视划分粒度的不同而不同，如子系统、模块、类、方法等。

- 凡是紧密相关的东西，都应该放在一起。
- 凡是被放在一起的东西，都是紧密相关的。

![](../images/high-cluster.png ":size=40%")

##### 低耦合

> 内聚反映了设计单元内部的相关性，耦合则是设计单元之间相关性的表征

如果两个设计单元之间存在某种关系，使得当一个设计单元发生变化或者出现故障时，另外一个设计单元也会受到影响，那我们就说这二者之间存在耦合。

内聚和耦合是彼此影响的两个因素。耦合不可避免.过度耦合是软件设计不稳定、不健壮的根源。

> 避免过度耦合的设计

一般来说，管理好了依赖，也就解决了大多数耦合问题。

![](../images/design-dependency.png ":size=40%")

1. 循环依赖造成紧耦合。循环依赖往往意味着设计不合理，或者依赖粒度过大。（切割依赖）
2. 依赖层级越深，耦合越紧。（通过依赖倒置断开链式依赖，需求方接口）
3. 依赖范围越广，耦合越严重。依赖范围过大，往往也和设计单元承担的职责过多有关。
4. 全局依赖和隐式依赖让耦合难以管理。
    - L 是全局变量。要避免这种耦合
    - L 是外部模块，封装 L
    - L 是隐含的知识（比如重复的代码）
    - L是一个稳定的接口时，J和K之间没有耦合关系
5. 对内部状态和数据的依赖是严重的耦合。内容耦合。在实际项目中常见的设计反模式，如Smart UI 和贫血模型，都是封装不足导致的内容耦合的结果。针对这种问题，最行之有效的做法是：除了纯粹的数据类，都应该尽量少暴露getter/setter方法。

耦合不局限于代码层面，它可以发生在设计的任何粒度上。例如，如果两个系统之间是通过一组API定义进行通信，那这两个系统之间就基于这组API形成了耦合，当你开发的系统使用了某种第三方框架，或者使用了某种消息通信的基础设施时，同时也在你开发的系统和该第三方框架以及消息通信基础设施之间建立了耦合。框架、通信基础设施或者API的变化都会影响依赖这些内容的模块。

#### 没有重复

重复是一种特殊的耦合。

DRY 原则

有句话叫“习惯成自然”，一旦某种编码风格形成习惯，久而久之，也就没人觉得这种重复是一种问题了。

无论重复是否真正有害，关注代码中的重复都能带来有价值的收益。最大的收益就是启发程序员注意关注点分离。

#### 没有多余的设计

##### 避免刻板地遵循某种设计范例

实际项目中常见的是滥用 IoP（面向接口编程）

IoP的本质是定义和实现的分离。定义指的是契约的定义，用接口承载。由于实现更容易变化也更难管。

应用IoP是一种基于投资回报的理性决策。

所有的设计范式，本身都是为了解决某个问题，它的权衡点在于投资回报。如果发现投资回报不合理，这时候就要做到“如无必要，勿增实体”，果断地把不该存在的设计删除。

##### 及时删除已经不再有用的代码

##### 避免为不可预见的未来编写代码

面向不确定的未来，最好的方法是反脆弱。

真正反脆弱的代码，是那些高内聚、低耦合，和业务的本质概念关联紧密、对应良好的代码。当然了，还应该具备良好的自动化测试。

#### 具备自动化测试

##### 保障功能正确

测试的原始目的就是保障功能正确

##### 提升代码可理解性

用测试作为文档的一个特别大的优势是它不会过时。

##### 保障软件系统的持续演进

##### 用契约和资产的观点看待自动化测试

测试的本质绝不仅是“测试”，它更本质的属性是“契约.

## 专业篇 建立扎实功底

### 高质量的需求

![](../images/require.png ":size=50%")

实践一再证明：在一个项目中，如果程序员没有积极投入到需求活动中，而只是被动地接收需求进行开发，那么往往会错漏百出，即使产品经理或需求分析师的能力很强，也无法改变这个结果。

> 是程序员的理解，而不是产品经理的设计，成为系统最后的功能。

#### 用结构化的方法分析需求

需求分析的本质是探索和发现。同时，沟通和确认是需求分析活动中的重要环节

##### 需求工程的三大活动

- 需求获取：正确地捕获业务方的诉求，对应达到的结果建立正确的预期。
    > 再小的需求也必然有期望达到的业务目标或者要解决的具体问题。
- 需求分析和定义：把业务方的诉求成功转换为对软件系统的需求，并进行清晰的表述。
    > 需求分析和定义是生成解决方案的过程：为了解决特定的问题，系统应该提供什么功能？这些功能包含哪些操作步骤？有哪些业务规则？
- 需求澄清和确认：让相关涉众（如开发人员和测试人员）都正确地理解需求，并达成一致。
    > 需求澄清和确认的核心挑战是细节。

##### 探索和发现用户的真正需求

需求分析的核心是探索和发现：通过持续探索，发现并确立真正的业务目标，从而设计出真正合理的方案，包括系统需求、操作步骤和业务规则等

##### 需求分析金字塔

![](../images/require-pyramid.png ":size=30%")

- 不断质疑，澄清业务目标

    为什么要做这个功能？如果不做这个功能，又会怎样？

    通过对业务目标进行质疑和确认，业务分析人员经常会发现业务目标中存在未澄清或者不合理的部分

- 探索业务流程，定义系统功能

    这一步的关键是“探索”，而不是“描述”

    系统功能就是业务流程中那些和软件系统有关的功能。

- 设计操作步骤，澄清业务规则

##### 共创、沟通和共识是需求分析活动成功的关键

- 用文档记录结果，不要用文档作为驱动

    尽可能早地引入需求沟通，进行群体性的共创活动

- 在协作空间讨论和完善需求

- 最大化发现能力，不畏惧需求变化

#### 定义业务目标

##### 目标要反映关键利益方的诉求

对同一个系统而言，不同的核心诉求对应的功能设计以及需求优先级可能是完全不同的。

在讨论业务目标的过程中，常常会出现下列问题。
- 为什么要做这个产品（或者功能）？要达到什么样的业务目标？
- 做出了这个产品（或者功能），期望的业务目标能达成吗？不做的话，可以通过其他途径达到业务目标吗？
- 谁将从这个产品（或者功能）中受益？又有谁可能会受到影响？

解决不同的功能需求能够达到相同的业务目标，需求开发仅仅是达到业务目标的手段。这一点在开发活动中务必注意。

#### 探索业务流程，定义系统功能

从业务目标到系统需求并不是一蹴而就的，联系它们的纽带是业务流程。

在开始定义系统功能前，先把业务流程定义清楚

##### 表达业务流程的方法

- 注重实效的UML

    UML就是适用于软件世界的统一表示法。与此相对的是线框图。线框图是随意的，在使用时很难达到精确
    
    把UML作为一种表示法，记录或者表达思考和讨论的过程

    把这种以沟通为目的、仅仅使用UML特征的有限子集来建模的方式，称为注重实效的UML。

- 多绘制草图，仅在必要时使用建模工具

- 用带有泳道的活动图表达业务流程

    有好几种UML图都适用于需求建模，这里列举三种。
    - 用例图：表达系统有哪些功能，执行者会使用系统的哪些功能。
    - 顺序图：表达参与者如何彼此交互，完成一个功能或业务。
    - 活动图：表达一个功能或业务设计的活动或流程。

    > 带有泳道的活动图是顺序图和活动图的结合体，最适合来表达业务流程

- 刻意地省略——抓住主要问题

    建模要注重实效。UML有一个非常好的机制——允许刻意地省略。

    在业务流程阶段，要能充分反映关键的业务节点，不要陷入操作细节

##### 积极地挑战业务流程

##### 使用业务事件推演业务流程

经验表明：正向的思考过程往往容易遗漏关键步骤。

EDBA（事件驱动的业务分析）的核心成功要素是：以业务事件为核心、以终为始、逆向思考。

业务事件指的是应该被关心的、具有业务价值的事件。

和事件相对应的是动作，从确定性上说，事件的确定性比动作的确定性更高，它有助于让我们更加关注业务流程的结果。

基于业务事件进行讨论，可以让需求讨论更聚焦、更清晰

> 16字口诀：事件优先，由后向前，关注例外，整理推演。

##### 从业务流程到系统需求

梳理业务流程的最终目的是软件开发，也就是要确定系统需要实现哪些功能.

系统需求是把“软件系统”作为研究对象，定义软件系统应该做什么，确定清晰的输入和输出

> 用例图最适合于表达系统需求

- 系统边界：明确哪些工作是在软件系统内完成的，哪些是在软件系统外完成的。用例的执行者处在边界外，用例处在边界内。
- 执行者：用例的发起者，经常是业务角色。涉及多系统交互时，执行者也有可能是外部系统。如果涉及定时任务，那么也可以把定时器作为一个特殊的执行者。
- 系统用例：执行者在系统边界上对系统进行的操作。
- 用例图：表达执行者、系统用例、系统边界之间关系的UML图。

业务流程的关注点是业务，系统用例的关注点则要低一个层级，它关注系统

在实际分析系统用例时，往往会对业务流程做进一步优化，还会考虑如何组织用例以体现良好的结构。

#### 完善操作步骤，澄清业务规则

##### 发现细节

一般来说，细节包括两个重要部分。

- 操作步骤
- 业务规则（约束）

##### 建立共识

- 所有参与者都对将要做的事情有一致的理解，没有歧义。
- 所有参与者都知道还有哪些问题尚未澄清。

“刻意地忽略”意味着大家知道哪些事情是暂时被忽略的，这很重要。

##### 表示法

- 用UML顺序图表示操作步骤
    
    UML顺序图擅长表示多个参与者之间存在互动的操作步骤。

- 用UML活动图表示操作步骤

    UML活动图适用于重点不在交互而在执行者所做动作的场景中，用来表示分支等更高效。

##### 用实例化的方式澄清需求

实例化需求

实例优于抽象

如果能想好怎么测试，那需求应该做成什么样也就变得很清晰了。这就是以终为始的思考方法。

![](../images/require-sample.png ":size=40%")

实例化需求的本质是沟通.在每个迭代开始之前，都组织实例化需求工作坊，就即将开发的需求进行讨论，并写出需求的关键实例.

#####　实例化需求的步骤

- 澄清目标
- 发现场景
- 澄清细节

Given-When-Then模式

当类似的示例比较多时，Given-When-Then模式也可以采用表格的形式来表达。

恰当地使用界面原型。使用界面原型作为补充工具，或者是在业务流程已经基本确定的情况下，再使用界面原型进行需求探索和设计，千万不要把界面原型作为唯一的需求探索工具。


### 领域建模

### 设计分解和责任分配

### 依赖、接口和契约

## 卓越篇 实现高效编码

### 用测试描述需求和契约

### 用领域模型指导实现

### 由外而内的设计

### 设计指令贯穿始终

### 让设计持续演进

### 精益思想和高效编程


