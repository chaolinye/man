# AWK

awk 常用于机械化的数据处理工作中： 改变数据格式, 验证数据的有效性, 搜索特定的数据项, 求和, 打印报表等

> 实际上, awk 是一个通用编程工具

## 运行 AWK 程序

```
awk [ -F fs ] [ -v var=value ] [ 'prog' | -f progfile ] [ file ...  ]
```

如果命令行省略输入文件，在这种情况下, awk 会将 program 应用到你接下来在终端输入的内容上面, 直到键入一个文件结束标志 (Unix 系统是组合键 Control-d)。

命令行中的程序被单引号包围. 这个规定可以防止程序中的字符 (例如 $) 被 shell 解释, 也可以让程序的长度多于一行.

## AWK 程序结构

每一个 awk 程序都是由一个或多个 **模式–动作** 语句组成的序列:

```awk
pattern { action } 
pattern { action } 
...
```

awk 的基本操作是在由输入行组成的序列中, 陆续地扫描每一行。每一个输入行轮流被每一个模式测试. 每匹配一个模式, 对应的动作 (可能包含多个步骤) 就会执行. 然后 下一行被读取, 匹配重新开始. 这个过程会一起持续到所有的输入被读取完毕为止。

> 特殊的模式 `BEGIN` 在第一个输入文件的第一行之前被匹配, `END` 在最后一个输入文件的最后一行被处理 之后匹配

在一个 **模式–动作** 语句中, 模式或动作可以省略其一, 但不能两者同时被省略. 如果一个模式没有动作，会将每一个匹配行 (也就是条件判断为真的行) 打印出来，也就是默认动作 `{ print }`。如果只有动作而没有模式，对于每一个输入行, 动作 (在这个例子里是打印第 1 个字段) 都会被执行.

> 因为模式与动作都是可选的, 所以用花括号将动作包围起来, 以便区分两者.

一个动作就是一个语句序列, 语句之间用分号或换行符分开.

在这些语句里, 不仅可以 使用内建变量, 比如 NF, 还可以自己定义变量, 这些变量可以用来计算, 存储数据等. 在 awk 中, 用户创建的变 量不需要事先声明就可以使用.

空行会被忽略
一个注释以井号 (#) 开始, 以换行符结束,
一条长语句可以分散成多行, 只要在断行处插入一个反斜杠即可

### 模式

模式汇总:

1. `BEGIN{ statements}`
    
    在输入被读取之前, statements 执行一次.

2. `END{ statements}`

    当所有输入被读取完毕之后, statements 执行一次.

3. `expression{ statements}`

    每碰到一个使 expression 为真的输入行, statements 就执行. expression 为真指的是其值非零或非空.

4. `/regular expression/ { statements}`
    
    当碰到这样一个输入行时, statements 就执行: 输入行含有一段字符串, 而该字符串可 以被 regular expression 匹配.

5. `compound pattern { statements}`
    
    一个复合模式将表达式用 &&(AND), ||(OR), !(NOT), 以及括号组合起来; 当 com-pound pattern 为真时, statements 执行.

6. `pattern1, pattern2 { statements}`
    
    一个范围模式匹配多个输入行, 这些输入行从匹配 pattern1 的行开始, 到匹配 pattern2 的行结束 (包括这两行), 对这其中的每一行执行 statements

> BEGIN 与 END 不与其他模式组合. 一个范围模式不能是其他模式的一部分. BEGIN 与 END 是唯一两个不能省略动作的模式.

如果有多个 BEGIN, 与其关联的动作会按照它们在程序中出现的顺序执行, 这种行为对多个 END 同样 适用. 我们通常将  BEGIN 放在程序开头, 将 END 放在程序末尾, 虽然这并不是强制的.


BEGIN 的一个常见用途是更改输入行被分割为字段的默认方式. 分割字符由一个内建变量 FS 控制. 默认情况下字段由空格或 (和) 制表符分割, 此时 FS 的值被设置为一个空格符. 将 FS 24 设置成一个非空格字符, 就会使该字符成为字段分割符.



## 实用一行手册

```awk
# 输入行的总数
END { print NR }
# 打印第 10 行
NR == 10
# 打印每一个输入行的最后一个字段
{ print $NF }
# 打印最后一行的最后一个字段
{ field = $NF }
END { print field }
# 打印字段数多于 4 个的输入行
NF > 4
# 打印最后一个字段值大于 4 的输入行
$NF > 4
# 打印所有输入行的字段数的总和
{ nf = nf + NF }
END { print nf }
# 打印包含 Beth 的行的数量
/Beth/ { nlines = nlines + 1 }
END { print nlines }
# 打印具有最大值的第一个字段, 以及包含它的行 (假设 $1 总是 正的)
$1 > max { max = $1; maxline = $0 }
END { print max, maxline }
# 打印至少包含一个字段的行
NF > 0
# 打印长度超过 80 个字符的行
length($0) > 80
# 在每一行的前面加上它的字段数
{ print NF, $0 }
# 打印每一行的第 1 与第 2 个字段, 但顺序相反
{ print $2, $1 }
# 交换每一行的第 1 与第 2 个字段, 并打印该行
{ temp = $1; $1 = $2; $2 = temp; print }
# 将每一行的第一个字段用行号代替
{ $1 = NR; print }
# 打印删除了第 2 个字段后的行
{ $2 = ""; print }
# 将每一行的字段按逆序打印
{ for (i = NF; i > 0; i++) printf("%s", $i)
  printf("\n")
}
# 打印每一行的所有字段值之和
{ sum = 0
  for (i = 1; i <= NF; i++) sum += $i
  print sum
}
# 将所有行的所有字段值累加起来
{ for (i = 1; i <= NF; i++) sum += $i }
END { print sum }
# 将每一行的每一个字段用它的绝对值替换
{ for (i = 1; i <= NF; i++) if ($i < 0) $i = -$i 
  print
}
```

## awk 数据类型

awk 的数据只有两种类型: 数值与由字符组成的字符串

