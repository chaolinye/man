# Unix 和 Linux 教程

## 什么是 Linux？什么是 Unix?

Unix 是一种类型的计算机系统，而 Linux 是 Unix 系统一个特定家族的名称。

所有 Unix 操作系统都有两个重要的特征： 多任务和多用户。

> 当一个命名后面带个 `X`，可以想想是不是和 Unix 有关系

### 什么是内核

当计算机启动时，计算机要经历一系列的动作，这些动作构成引导过程。该过程的最后一个动作是启动一个非常复杂的程序，这个程序称为**内核(kernel) **。

内核的作用是控制计算机，充当操作系统的核心。由于这一点，所以内核总是一直运行

内核提供的服务：

- 内存管理（虚拟内存管理，包括分页）
- 进程管理（进程创建、终止、调度）
- 进程间通信（本地、网络）
- 输入输出（通过设备驱动程序，即实现与物理设备实际通信的程序）
- 文件管理
- 安全和访问控制
- 网络访问（如 TCP/IP)

内核可分为两大类：

- 单内核
    > 代表：Linux
    > 优点：速度快；缺点：难以设计和维护
- 微内核
    > 代表：FreeBSD
    > 优点：模块化设计，易于理解和维护，且更易于定制；缺点：比较慢

> Unix = 内核 + 实用工具

### Unix 的历史

![](../images/unix-history.png)

### Linux 发行版

Linus Torvalds 和 Linux 项目所创建的只是一个内核，并不是一个完整的操作系统。

要形成一个操作系统，需要为内核寻找所需的各种组件， 并将它们组装在一起。

而这个事情已经有很多团队在做了，基于 Linux 的操作系统成为 *Linux 发行版(distribution)*

大多数 Linux 发行版都使用自由软件基金会的 GNU 实用工具。基于这一原因 ， FSF 坚持基于 Linux 的操作系统实际上应该称为 `GNU/Linux`

> Linux 基于开放源代码运动编写的通用公共许可证(general publie lieense, GPL)

> 当在软件上应用 GPL 协议时，允许任何人发行该软件、查看其源代码、修改该软件并发行
修改后的软件。此外， GPL 协议要求任何重新发行软件（包括修改后的版本）的人，都不能
剥夺软件的使用自由或者添加自己的限制—~这是 GPL 的关键部分。

### BSD 发行版

BSD 是 20 世纪 80 年代两大 Unix 主流之一（ 另一个是 `System V`) 。 BSD由加利福尼亚大学伯克利分校计算机科学系开发。

BSD 在完全重写了 AT&T 的 UNIX 代码后，重新命名为 `FreeBSD`.

> Macbook 的 OS X 系统就是基于 FreeBSD 构建的

FreeBSD 只适用于 PC 端，为了能移植到其它类型计算机上，提供了 `NetBSD`

另外，还有一个主要关注安全和密码学的版本：`OpenBSD`

> BSD 许可证远没有 GPL 严格。在 BSD 许可证之下，允许使用部分 BSD 创建新产品而不共享该新产品。

> 因为 BSD 许可证的原因，企业更愿意基于 BSD 构建自己的商业操作系统。

Linux 比 FreeBSD 更成功的原因：

- Linux 基于 GNUGPL 名义发行，而 GNUGPL 协议鼓励共享。
- Linus Torvalds 在 1991 年发行了 Linux 内核，而 386/BSD 直到 1992 年才发行，所以 Linux 在发行时间上占得先机

## Unix 连接

可以通过下述两个简单的公式来描述所有的计算机系统：

- 计算机＝终端＋主机
- 终端=输入设施＋输出设施

Unix 的两种终端：

- 字符终端：只使用文本
- 图形终端

> Unix 的 GUI 都基于 一个称为 X Window 的系统，而且对 X Window 的基本支持 由 一个称为 X 终端的图形终端提供

> `ssh -X` 远程连接 GUI

## Unix 基础知识

> 关于 CRLF 换行符的由来: 之前输出终端主要是打印机，打印机换行需要两个动作打印机的托架回车(carriage return)，然后换行(linefeed)

> 为了安全，Unix 登录时不会提示用户不存在，而是提示登录错误，让攻击者不知道到底是用户名还是密码错误。

> 用户标识习惯上只使用小写字母。

注销的方法：`logout`、`exit`、`login`、`^D`

> ^ 代表 Ctrl。^D 一般绑定 eof 符号，在 shell 中输入 eof，代表没有新的命令了，shell 会自动退出

> `passwd` 改变口令

> `last` 查看所有用户的登录信息

## GUI

GUI 相对于文本界面(也称命令行界面，CLI)的优势之一：一次可以看到多个程序，程序之间的切换也很方便

X Window 是一个为使用图形数据的程序提供服务的系统。在 Unix 世界中 ， X Window 在 3 个方面非常重要。

> 通常称 X Window 为 X，最重要的发行版是 X11

1. 它是儿乎所有 GUI 的基础 。
2. X Window 允许在远程计算机上运行程序，井在自己的计算机上显示完整的图形输出．
3. X Window 使得使用各式各样的硬件成为可能。此外，还可以同时使用不止一台显示器。

X Window 被设计成 GUI 和硬件之间的标准化界面，本身并不提供图形界面，提供实际 GUI 的是 *窗口管理器（Window manager）*。

但是窗口管理器也就提供基本的图形界面，但也就提供最基础的功能，用户体验并不好，所以又出现更上层的桌面环境(Desktop Environment)，也称桌面管理器

Unix GUI 的抽象层次

![](../images/unix-gui.png)

Linux 系统最流行的两种桌面环境: `KDE`（Kool Desktop Environment） 和 `Gnome`(GNU Network Object Model Environment)

> KDE 的窗口管理器是 `kwm` , Gnome 的窗口管理器是 `Metacity`

> KDE 先出现，但是 GNU 觉得许可证不够自由，因此又创建了 Gnome

> KDE 更美观；Gnome 更简单。

> Gnome 用户喜欢控制事情如何运转， 而 KDE 用户喜欢控制事情的外观

## Unix 基础知识 2

### 多任务

Unix中的执行单元是进程。

> 进程就是装载到内存中准备运行的程序，以及程序的数据与跟踪程序状态所需的信息

Unix 的多任务并行是通过多个进程轮流使用处理器一段极短的时间来实现的，这一段极短的时间称为时间片(time slice) 。典型的时间片通常是 10 毫秒。

> 时间片的长短往往是动态的

### GUI

GUI 的菜单项的文本单词中往往会有一个字母有下划线，使用 ALT(accelerator) 加速键和这个字母可以快速选择菜单。

### 运行级别

典型的 Linux 运行级别：

| 运行级别 | 描述 |
| :--: | :--: |
| 0 | 停机（关机）|
| 1 | 单用户模式：命令行 |
| 2 | 非标准化 |
| 3 | 多用户模式: 命令行 |
| 4 | 非标准化 |
| 5 | 多用户模式: GUI |
| 6 | 重新启动 |

在大多数情况下， Linux 默认引导至运行级别 3 或者运行级别 5

系统维护时，系统管理员将重启 Unix 系统到运行级别 1（单用户模式，也就是所谓系统维护模式）

修改默认运行级别：修改 `/etc/inittab` 中的 `initdefault` 的值

临时修改 init

```bash
sudo init 6 # 等同于运行 reboot 命令，重启
sudo init 0 # 等同于运行 shutdowm now 命令，关机
```

> 这是老的服务管理 init 程序才能用的方法，新的服务管理程序 systemd 可以参考 [系统服务](http://localhost:3000/#/docs/linux/system-service?id=%e7%ae%a1%e7%90%86-target-unit) 章节

### 切换超级用户

su(substitute userid)命令允许您变换到另一个用户标识. 
sudo(substitdute the userid and do something)命令允许您以另一个用户标识的名义执行一条单独的命令．

> sudo 输入一次口令后，在一定时间内不必再次输入， 大多数系统的默认时间是 5 分钟

> 需要用户标识位于 /etc/sudoers 中才能使用 sudo 命令

### 系统启动或者停止时发生什么事情?

查看系统消息

```bash
dmesg | less
```

## Unix 键盘的使用

### Unix 的终端

CLI 的使用方式有若干种。当使用自己的计算机时，可以使用虚拟控制台或者终端窗口（包括 Konsole 程序）。当使用远程主机时，可以通过 ssh 程序连接， ssh 程序将充当终端仿真器

Unix 最初的终端是 Teletype，所以后续的虚拟终端的名字都是 `tty` 开头的

Teletype 的输出是通过打印头在纸上打印实现的，所以输出也经常被称为 print(打印)

查看当前使用的终端

```bash
echo $TERM
```



### Unix 的键盘信号

Ctrl 键也被称为修饰键，一般简写为 `^`

Unix 中把很多 `^<key>` 的组合键绑定了一个信号，进程通过接收这些信号进行相应的处理

```bash
# 查看系统的键盘映射
stty -a
# 修改键盘映射
stty erase ^H
# 还原终端配置
stty sane
reset
```

> stty 是 set terminal（设置终端）的意思

常见的键盘信号：

| 信号 | 键 | 作用 |
| :--: | :--: | :--: |
| erase | `<Backspace>/<Delete>` | 删除键入的最后一个字符 |
| werase | `^W` | 删除键入的最后一个单词 |
| kill | `^X/^U` | 删除整行 |
| intr | `^C` | 停止正在运行的程序 |
| quit | `^\` | 停止程序并保存 core 文件 |
| stop | `^S` | 暂停屏幕显示 |
| start | `^Q` | 重新启动屏幕显示 |
| eof | `^D` | 指示已经没有数据 |

> Backspace 键属于快捷键，等同于 `^H`;Delete 等同于 `^?`

> 在 shell 中按下 `^D`, 接受到 eof 信号后，shell 会认为已经没有要执行的命令了，就会自动 logout

> quit 信号相比于 intr 信号的差异在于不仅停止程序，而且还会告诉 Unix 为此时内存中的内容制作一份副本。该信息存储在一个磁芯文件(core file) 中。

> 初期的计算机的内存使用的是 core（磁芯）设备，因此 core 也成了内存（memory）的代名词。以前程序调试是一个特别困难的过程，尤其是程序意外终止时．程序员使用的一种技术，就是使操作系统在程序终止时愉出该程序使用的内存中的内容一－这就是所谓的磁芯转储(core dump),coredump 其实就是内存转储，core file 就是内存文件。


### 返回和换行

Unix 最初的终端是 Teletype， Teletype 通过打印头在纸上打印来输出。在这种情况下换行需要两个指令，1. CR（carriage return，托架返回）把打印头的托架返回最左边位置；2. LF（linefeed，换行），使打印纸向上移动一行。因此，序列 CR-LF 执行打印一个新行所需的准备动作。

在键盘上，按下 `<Return>` 键或者 `^M`(它们等价）可以发送一个 CR 码。 按下 `<Linefeed>` 或者 `^J` 键可以发送 LF 码

> 以前的键盘有 Return 和 Linefeed 两个键

使用场景：

1. 文件中，Unix 使用 `^J` 字符标记每行的结束
2. 在终端输入字符时，在行的末尾按下 `<Return>` 键。 这样做可以发送返回字符，也就是 `^M`。
3. 当数据显示时，每次向终端发送一行字符,每行必须以 `^M^J` 结束。

> 如果输入时 `^M` 失效了，也可以使用 `^J` 代替

不同场景对于 `^M` `^J` 的使用不同，Unix 会在其中做转换

1. 在键入过程中，无论何时，当按下 `<Return>` 键时， Unix 都将返回字符改变为新行字符。也就是说， Unix 将 `^M` 改变为 `^J` 。
2. 当数据要写到终端上时， Unix 将每个新行字符改变为返回字符＋新行字符。也就是说， Unix 将 `^J` 改变为`^M^J`。

> 即输入时在每行的末尾按下 `Return` 即可，其它的让 Unix 去做

> Windows 的文件中使用 `^M^J` 标记每行的结束，因此 Windows 和 Unix 的文件互传要做好相应的转换，最后传输程序就能完成，如果不行，可以使用实用工具来做 `dos2unix`

## 实用工具

在系统中查找程序：

```bash
# 回答，将会运行那个程序
which date
# 备用
type date
# 备用
whence date
```

停止程序：

1. 等待输入时，通过 `^D` 发送 eof 让程序自行退出
2. 通过 `^C` 发出 intr 信号让程序停止

显示时间和日期

```bash
# 显示时间和日期
date
## 显示 UTC 时间
date -u
# 显示日历
cal
## 显示某一年的日历
cal 1952
```

> 所有的 Unix 系统都使用协调世界时 (Coordinated Universal Time, UTC), 它是格林威治标准时间(Greenwich Mean Time, GMT) 的现代名称。 Unix 在需要时默默地在 UTC 和本地时区之间进行转换。

查看系统信息

```bash
# 显示示系统已经运行多长时间（也就是连续运行）的有关信息：
uptime
# 查看计算机名称
hostname
# 显示操作系统名称
uname
## 显示操作系统更多的信息，主要是 Linux 内核版本
uname -a
```

查看自己的信息

```bash
# 显示当前用户标识
whoami
who am i
# 查看配额
quota
```

查看其它用户的信息

```bash
# 显示当前登录的所有用户标识
users
# 显示更多的信息
who
# 显示更多更多的信息
w
```

终端临时上锁

```bash
# 默认锁住 15 分钟，超时自动解锁。需要输入临时密码
lock
# 设置锁住 5 分钟
lock -5
```

让 Unix 提醒何时离开

```bash
# 10:30 提醒
leave 10:30
# 15 分钟后提醒
leave +15
```

内置计算器 `bc`

> bc 是一个完全可编程的数学解释器, 功能十分强大

bc 中可以使用变量

```
w=160
r=(w*2)*1000
d=(w/3)*2000
r+d
```

## Unix 手册与 Info

Unix 传统思想:

- 在请求帮助之前尽最大的努力自已解决间题：
- 当他人请求您的帮助时，心甘情愿地帮助他人。

> 这种思想被抽象成 `RTFM`（Read The Fucking Manual）

### 什么是 Unix 手册? man

Unix 内置了手册，通过 `man command` 可以学到其它任何命令

man 使用技巧：

1. 在看某个命令的手册时，发现一个关联命令，可以通过 `!man another-command<Return>` 来查看，看完后，按下 `q` 退出新的 man，然后按下 Return 回到老的 man

    > 在使用 man 时，可以使用 `!command` 执行命令，执行完毕后按 `Return` 返回 man

2. 如果系统没有安装 man 或者某个命令的手册不在，可以通过 Google 搜索 `"man comman"`（注意要带上双引号） 来查看手册

### Unix 手册的组织方式

整个手册分为 8 节，编号从 1 到 8

1. 命令

    > 最重要的部分，一般人只需要关注这节

    > 在查找信息或者处理问题时，如果看到了手册第 1 节中命令的引用，就应该花点时间看看该引用

2. 系统调用
3. 库函数
4. 特殊文件
5. 文件格式
6. 游戏
7. 杂项信息
8. 系统管理

> 每一节又被划分为几个小节。例如 ， 在一些 Linux 系统上，在第 3 节（库函数）中，就有以下几个小节：第 3 c 节是标准的 C 函数： 第 3f 节是Fortran 函数；第 3m 节是数学函数；第 3s 节是标准 1/0 函数；而第 3x 节则是特殊函数。

```bash
# 默认查看第一节
man kill
# 指定节号
man 2 kill
```

```bash
# 查看第一层级章节
man man
# 查看第二层级章节
man 1 intro
```

说明书页的标准格式

| 标头 | 含义 |
| :--: | :--: |
| Name | 命令的名称和用途 |
| Synopsis | 命令语法 |
| Description | 完整描述（可能很长） |
| Environment | 命令使用的环境变量 |
| Author | 程序员的名字 |
| Files | 对该命令重要的文件列表 |
| See alse | 查看相关信息的位置 |
| Diagnostics | 可能的错误和警告 |
| Bugs | 错误、缺点、 警告 |

```bash
# 查看多个命令的 Name 信息（会查找所有章节）
# 字母 f 代表单词 "files"。每个说明书页都存储在一个单独的文件中。当使用-f 选项时，就是告诉 man 查找哪些文件。
man -f time date
# 等效写法
whatis time date

# 查找 Name 中包含某个关键字的说明书页
man -k manual
# 等效写法
apropos manual
```

> 大多数命令实际上是程序。但是，有些最基本的命令是由 shell 本身执行的，这些命令称为内置命令（可以通过 `which` 和 `type` 来确认）．这些命令记录在 shell 的说明书页中．手册中没有它们各自的单独条目. 可以通过 `man bash` 等来查找内置命令的信息


### 命令语法

通常，Unix 命令语法可以表示为 

`命令名称 选项 参数`

> 有时候会看到称选项为开关(Switches)或者标志(Flags) ,

> `-` 选项一般可以组合在一起，例如, `-l -F` 可以组合成 `-lF`

> 连字符一般读 `dash`，但是老一辈程序员读 `minus`

除了最初的`单连字符+字母`的选项语法，后来 GNU 实用工具中为了让选项更容易理解和记忆，引入了 `--` `双连字符 + 单词` 的选项语法

> 有利有弊，较长选项键入速度较慢，并且更易于拼错

> BSD 系统的选项语法甚至没有连字符，都是字母

命令的每个部分之间需要用空白符隔开。

> 在命令行中空白符指的是一个或者多个连续的空格或者（对于一些 shell 来说）制表符。在其他情形中，空白符可能指一个或者多个连续的空格、制表符或者新行字符

Unix 命令语法规则:

**ls** [**-aAcCdfFgilLqrRstul**] [*filename*...]

1. 方括号中的项是可选的。
2. 不在方括号中的项是必选项，必须作为命令的一部分输入。
3. 黑体字必须按原样准确键入。
4. 斜体字必须用适当的值代替。
5. 后面接省略号（…）的参数可以重复任意多次。
6. 如果一个单独的选项和一个参数组合在一起，那么该选项和参数必须同时使用。

    > **man** [**-P** *pager*] [**-S** *sectionlist*] *name*...

7. 由（竖线）字符分开的两个或多个项，表示可以从这个列表中选择一个项

    > **who** [**-abdHilmpqrstTu**] [*file* | *argl* *arg2*]

> 在一些系统上， 没有黑体字和斜体字。在不显示斜体字的系统上，通常使用下划线代替斜体

作为一种语法摘要，一些版本的手册使用简化的形式，不会列出单个的选项，而是使用单词 "options" 表示。

无论在语法摘要中是否能看到选项，在详细的命令描述中都将枚举并解释各个选项。

## shell

shell 是一个程序，充当用户界面和脚本解释器，允许用户输入命令以及间接地访问内核的服务。

shell 的两大家族

1. Bourne Shell 家族：sh、ksh、bash

    > Bash 是历史上最流行的shell。名称 Bash 代表 "Bourne-agine shell"

2. C-Shell 家族: csh、tcsh

    > 语法类似于 C 语言

    > C-Shell 的最大缺点，不适合于编写 shell 脚本

```bash
# 查看系统上安装了哪些 shell
less /etc/shells
# 显示当前 shell 的名称
echo $SHELL
```

登录时启动的 shell 叫做登录 shell，在登录 shell 中启动的新 shell，是非登录 shell

修改登录时使用的 shell 有两种方法：

1. 修改 `/etc/passwd` 文件
2. 执行命令: **chsh** [**-s** *shell*] [*userid*]，比如修改当前用户标识的登录 shell 为 bash: `chsh -s /bin/bash`

    > 建议使用这种方法，更加的安全

shell 的基本特性

- 交互式 shell

    > shell 既可以充当用户界面(交互式 shell)，也可以作为脚本解释器（非交互式 shell）。

- 进程
- 环境变量
- shell 变量
- shell 选项
- 元字符
- 引用
- 外部命令
- 内置命令
- 搜索路径
- 命令替换
- 历史列表
- 自动补全
- 命令行编辑
- 别名
- 初始化文件
- 注释

### 变量和选项

当使用 Unix shell 时，有两种不同类型的变量。它们分别称为 "shell 变量”和“环境变量”

> 对于其它编程语言，变量的值会有多种类型，但是对于 shell, 变量几乎总是存储一种类型的数据，即字符，也就是一串纯文本字符

Unix 系统中，每个对象都被表示为一个文件或者进程。

在进程运行过程中，它需要访问所谓的环境，即一组用来存放信息的变呈

在子进程创建时，系统为子进程复制了父进程的环境。我们说于进程继承了父进程的环境。这意味着父进程可以访问的全部环境变量，现在子进程也可以访问。

> 即父进程的环境变量可以传递给子进程，但这个传递是复制的，也就是说子进程中就算修改环境变量也不会影响到父进程中的环境变量的值

环境变量类似于全局变量（对多进程有效），shell 变量类似于局部变量（只对当前进程有效）

> 环境变点并不是真正的全局变量，因为子进程对环境变量的修改并不能传递回父进程。

一般来说，全局变量的命名应该用全大写，局部变量用小写

但是在 Bourne shell 家族中，环境变量和 shell 变量都是全大写

这是因为在 Bourne shell 家族中 ，只允许创建局部变量。也就是说，**每个新变量被自动地设置为 shell 变量**。
如果希望某个变量同时成为环境变量，必须使用一个称为 `export` 的特殊命令。 
`export` 命令将 shell 变量修改为 "shell+环境”变量。当这样做时，就可以称将变量导出(export)到环境中。

> 即环境变量一定同时是 shell 变量，

```bash
# 显示环境变量
env
## 或者
printenv

# 显示 shell 变量+环境变量，
set

# 显示单个 shell 变量或者环境变量
echo ${VAR_NAME}
## 如果没有歧义，还可以省略掉花括号
echo $VAR_NAME

# 创建 shell 变量
NAME=value
# 导出环境变量
export NAME
# 创建并导出环境变量
export NAME=value

# 删除变量/复位变量
unset NAME
```

对于 C-Shell 家族来说，可以使用 shell 变量控制 shell 行为的各个方面。对千 Bourne shell 家族来说，则需要使用 shell 选项

shell 选项设置或复位的方式有两种。第一种，当 shell 启动时 ， 可以以普通的方式指定选项，即为命令指定一个或者多个选项

设置选项: **set** **-o** *option*

复位选项: **set** **+o** *option*

```bash
# 显示所有 shell 选项的当前状态
set -o
# 以一种紧缩的格式显示相同信息
set +o
```

Bourne shell 家族：交互式 shell 选项汇总

![](../images/shell-options.png ":size=50%")

### 命令和定制

当使用 shell 时，还有许多其他字符拥有特殊的含义。我们称这样的字符为 **元字符(metacharacter)**

shell 中使用的元字符:

![](../images/shell-metachar.png ":size=50%")

有时候， 可能希望按字面上的含义使用元字符，而不使用其特殊的含义。在这些情况中，必须告诉 shell 按字面意义解释字符。这样做时，可以称其为 **引用字符**。

字符的引用方法有 3 种：

- 使用反斜线引用单个字符（称为转义了这个字符）。

    > 当使用反斜线引用单个字符时，我们称反斜线为**转义字符(escape character)**。

- 使用单引号引用一串字符。
- 使用双引号引用一串字符，但是保留 `$`（美元）、`（反引号）和 \ 反斜线的特殊含义。

在解析命令之后, shell 决定如何处理命令，其可能性有两种。一些命令在 shell 的内部，这意味着 shell 可以直接解释它们。这些命令是内部命令， 通常称为 **内置命令**(builtincommand, 或者简称为 builtin) 。 其他所有命令是外部命令 ，即必须独自运行的独立程序。

> 当输入内置命令时， shell 在自己的进程内运行该命令

查看某条命令是不是内置命令最快捷的方式就是使用 `type` 命令。

**type** *command*...

```bash
# 显示所有内置命令列表
help

## 查看一个内置命令
help [-s] [command...]
```

> 当编写 shell 脚本时，可以使用特殊的内置命令 for 、if、 while 等来控制脚本流程．这些命令有时候称为关键字．


shell 如何知道在什么地方查找外部命令呢? shell 检查 PATH 环境变量。与所有的变量一样， PATH 包含一串字符，这串字符就是一系列目录名称，我们称之为**搜索路径**。

修改搜素路径

```bash
export PATH= "$PATH:$HOME/bin:." 
```

修改 shell 提示

```bash
export PS1="$ "
```

**命令替换**允许在一条命令中嵌入另一条命令。shell 首先执行嵌入的命令，并且用输出替换该命令。然后 shell 再执行整个命令。

```bash
export PS1=" `whoami` $"
```

> 反引号字符只在命今替换中使用

历史列表

```bash
# 指定历史命令列表的大小
export HISTSIZE=SO
# 查看历史列表
history
# 执行上一条命令
!!
# 执行某编号的命令
!24
```

> Bash 支持一个额外的特性，即使用 `^R` (可以认为它是*重新调用*键）．按 `^R` 键并键入一种棋式，然后 Bash 将重新调用包含该模式的最近一条命令

别名：

**alias** [*name*=*commands*] 

```bash
# 创建别名
alias info='date; uname; who'
# 显示所有别名
alias
# 删除别名
unalias info
# 删除所有别名
unalias -a
# 在有别名的情况下，运行原命令
\ls
```

### 初始化文件

**登录文件**、**环境文件**和**注销文件**允许您在 3 个不同的时间执行那些希望自动执行的命令，这 3 个时间分别为登录时、新 shell 启动时和注销时。

![](../images/shell-init.png ":size=50%")

> 标识 `rc` 代表 "run commands, 运行命令"，也就是特定程序每次启动时自动运行的命令．

登录时启动的 shell 称为**登录 shell** 。其他的交互式 shell 称为**非登录 shell** 。

(1) 登录 shell 执行登录文件和环境文件。
(2) 非登录 shell 只执行环境文件。

但是 Bash 的登录 shell 只执行登录文件，而不执行环境文件。这意味着 Bash 用户为 了强制执行环境文件，必须在登录文件中末尾再写个额外的命令执行环境文件

初始化文件中应该放置什么内容？

登录文件有两项任务：设置环境以及初始化工作会话。因此，登录文件中应该包含下述命令： (1)创建或者修改环境变量的命令： (2)执行所有一次性操作的命令

> 环境变量能够被子进程所继承，所以在登录文件中配置即可

环境文件有一项不同的任务：设置不能在环境中保存的自定义项，特别是 shell 选项项、别名和函数。因为这些设置没有存储在环境中，所以每次启动新 shell 时必须重新创建它们

### 子 shell

有时候，可能希望在子 shell 中运行一小组命令，或者就一条命令，但又不希望启动一个全新的 shell。
Unix 为这种情况提供了一个特殊的工具：将命令括在圆括号中。这样就可以告诉 shell 在子 shell 中运行命令。

使用子 shell 的最常见的原因是防止 cd(change directory, 改变目录）命令影响当前的 shell。其通用格式为：

```bash
(cd directory; command)
```

### 命令的条件执行

```bash
# 命令1成功执行命令2
command1 && command2
# 命令1失败执行命令2
command1 || command2
```

## 标准 I/O: 重定向和管道

### Unix 设计准则

Unix 的设计准则可以用两句话概括：
- 程序或者命令应该是一个工具，它只完成一件事情，但一定要完成好这件事情。
- 当需要新工具时 ，最好对现有的工具进行组合，而不是编写一个新工具。

> 有时候将这一设计准则描述为："Small is beautiful(小的就是完美的）”或者 " Less is more(少的就更好）＂。

### 标准输入输出

为了方便连接工具，让程序无需关系输入和输出的来源，Unix 设计了一种读取数据的通用方法（称之为标准输入）和两种写出数据的通用方法（称之为标准输出和标准错误）

> 标准输入、标准输出和标准错误通常缩写为 stdin 、 stdout 和 stderr

在登录时， shell 会自动地将标准输入设置为键盘，将标准输出和标准错误设置为屏幕

当将标准输出发送给文件时，我们称之为重定向标准输出

```bash
# 重定向 stdout，覆盖
sort > names
# 重定向 stdout，追加
sort >> names
# 重定向 stdin
sort < /etc/passwd
```

> 为了避免重定向覆盖已有文件，可以开启选项 `set -o noclobber`，开启后可以用 `>|` 取代 `>` 临时忽略 noclobber，

在 Unix 进程中，每个输入源和每个输出目标都由一个唯一的数字标识，这个数字称为**文件描述符**(file descriptor)

重定向输入或输出的正式语法是在文件描述符数字之后使用 `<` 或 `>`

默认情况下， Unix 为每个进程提供 3 个预定义的文件描述符，而且大多数时候这已经够用。
默认的文件描述符是 0 代表标准输入， l 代表标准输出 ， 2 代表标准错误

所以重定向的标准语法是

*command* **0<** *inputfile* **1>** *outputfile* **2>** *errorfile*

组合标准输出和标准错误：

基本思想就是将一种类型的输出重定向到一个文件，然后再将另 种类型的输出重定向到同一个位置。相关语法为:

*command* *x***>** *outputfile* *y***>&***x* 

例如:

```bash
# &1 可以理解为引用 1 的重定向
sort 1> output 2>&1
# 简写
sort > output 2>&1
# 都追加
sort >> output 2>&1
```

抛弃输出

```bash
update > /dev/null 2>&1
```

![](../images/shell-stdio.png ":size=50%")

### 管道线

定义了标准输入输出，确认让程序不再需要关注输入和输出的来源，但是再连接程序时，往往需要使用临时文件来做粘合，很是麻烦。

为了使这样的解决方法简单些， shell 允许创建一序列命令，
在这一序列命令中， 一个程序的标准输出可以自动地发送给下一个程序的标准输入。
当这样做时，两个程序之间的连接就是`管道(pipe)`, 而命令序列本身称为`管道线(pipeline)`

```bash
cat file1 file2 file3 | grep Harley | wc -l
```

当创建管道线时，必须使用能够从标准输入读取文本，并向标准输出写入文本的程序。我们称这样的程序为`过滤器`，许多程序都是过滤器

管道线分流：

有时候需要在管道线的某个环节保留一份输出。使用 tee 命令可以实现这一目的。tee 命令的作用就是从标准输入读取数据，并向标准
输出和一个文件各发送一份数据。 tee 命令的语法为

**tee** [**-a**] *file*...

```bash
who | tee temp.txt | less
```

## 过滤器

过滤器就是任何能够从标准输入读取文本数据并向标准输出写入文本数据（每次一行）的程序

最有用的 Unix 过滤器

![](../images/unix-filter.png ":size=50%")
![](../images/unix-filter2.png ":size=50%")

```bash
# 在每行前面加个行号
cat -n data
# 比较二进制文件
cmp file1 file2
# 在二进制文件搜索字符串
strings /usr/bin/sort
```

sed 的替换语法

[/*address*|*pattern*/]**s/***search*/*replacement*/[**g**]

```bash
# 替换 5 到 10 行
sed '5,10s/harley/Harley/g' names
```

## 正则表达式

正则表达式(regular expression)通常简写为 `regex` 或 `re`, 是一种指定字符串模式的简洁方式

## References

- [Unix & Linux 大学教程]()
