# Unix 编程艺术

## 哲学

Unix有它自己的文化；有独特的编程艺术；有一套影响深远的设计哲学。理解这些传统，会使你写出更好的软件，即使你是在非 Unix 平台上开发。

### Unix 之失

Unix文件在字节层次以上再无结构可言。文件删除了就没法恢复。Unix的安全模型公认地太过原始。作业控制有欠精致。命名方式非常混乱。或许拥有文件系统本身就是一个错误。

Unix最持久的异议恰恰来自Unix哲学的一个特性，这一条特性是Xwindow设计者首先明确提出的。X致力于提供一套 **“机制，而不是策略”​**，以支持一套极端通用的图形操作，从而把使用工具箱和界面的“观感”​（策略）推后到应用层。Unix其它系统级的服务也有类似的倾向：行为的最终逻辑被尽可能推后到使用端。

这个“错误”换来至关重要的优势：策略相对短寿，而机制才会长存。

### Unix 之得

- 开源软件    
    自由共享代码，随源代码发布就是 Unix 的文化特色
- 跨平台可移植性和开放标准   
    Unix API 是 “可移植操作系统标准”(Portable Operating System Standard) 的事实标准，因此，POS很快就被大家加了后缀变成了“POSIX”​[缩写为 POSIX 是为了读音更像 Unix]​
- Internet和万维网
    Unix对于TCP/IP的实现相对于其它系统更加稳固可靠
- 开源社区   
    由于代码共享，Unix 社区一直在吸纳最优秀的人才
- 从头到脚的灵活性   
    自诩比Unix现代和界面友好的操作系统，都有着脆弱狭隘难用的编程接口。在这样的操作系统中，完成设计者（指操作系统）预见的任务很容易，但如果要完成设计者没有预料到的任务，用户不是无计可施就是痛苦不堪。    
    相反，Unix具有非常彻底的灵活性。Unix提供众多的程序粘合手段，这意味着Unix基本工具箱的各种组件连纵开合后，将收到单个工具设计者无法想象的功效。Unix传统将重点放在尽力使各个程序接口相对小巧、简洁和正交——这也是另一个提高灵活性的方面。整个Unix系统，容易的事还是那么容易，困难的事呢，至少是有可能做到的。
- Unix Hack 之趣
    对于程序员和开发人员来说，如果完成某项任务所需要付出的努力对他们是个挑战却又恰好还在力所能及的范围内，他们就会觉得很有乐趣。因此，趣味性是一个峰值效率的标志    
    在 Unix 世界里，操作系统以成就感而不是挫折感来回报人们的努力。Unix 下的程序员通常会把Unix当作一个积极有效的帮手，而不是把操作系统当作一个对手还非得用蛮力逼迫它干活。
- Unix的经验别处也可适用

### Unix 哲学基础

Unix哲学起源于Ken Thompson早期关于如何设计一个服务接口简洁、小巧精干的操作系统的思考，

Unix管道的发明人、Unix传统的奠基人之一 Doug McIlroy 的 Unix 哲学：

- 让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。
- 假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏格式和二进制格式输入。不要坚持使用交互式输入。
- 尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是在几星期内。对拙劣的代码别犹豫，扔掉重写。
- 优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事，必先利其器。

总结：Unix哲学是这样的：一个程序只做一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。

最伟大的C语言大师之一，Rob Pike 的 Unix 哲学：

原则1：你无法断定程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已经证实那儿就是瓶颈所在。  
原则2：估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度。  
原则3：花哨的算法在n 很小时通常很慢，而n通常很小。花哨算法的常数复杂度很大。除非你确定n总是很大，否则不要用花哨算法（即使n很大，也优先考虑原则2）​。  
原则4：花哨的算法比简单算法更容易出bug、更难实现。尽量使用简单的算法配合简单的数据结构。(**拿不准就穷举**)   
原则5：数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法  
原则6：没有原则6。

Unix 哲学可以概括为：

1. 模块原则：使用简洁的接口拼合简单的部件。   
    > 计算机编程的本质就是控制复杂度。   
    要编制复杂软件而又不至于一败涂地的唯一方法就是降低其整体复杂度——用清晰的接口把若干简单的模块组合成一个复杂软件如此一来，多数问题只会局限于某个局部，那么就还有希望对局部进行改进而不至牵动全身。
2. 清晰原则：清晰胜于机巧。  
    > 维护如此重要而成本如此高昂；在写程序时，要想到你不是写给执行代码的计算机看的，而是给将来阅读维护源码的人（包括你自己）看的。   
    为了取得程序一丁点的性能提升就大幅度增加技术的复杂性和晦涩性，这个买卖做不得。  
    永远不要去吃力地解读一段晦涩的代码三次，第二次就应该加注释
3. 组合原则：设计时考虑拼接组合。
    > 在输入输出方面，Unix传统极力提倡采用简单、文本化、面向流、设备无关的格式  
    在经典的Unix下，多数程序都尽可能采用简单过滤器的形式，即将一个输入的简单文本流处理为一个简单的文本流输出。  
    根据经验如果程序不采用简单的文本输入输出流，往往极难衔接。  
    GUI场景要把复杂的交互程序跟干粗活的算法程序分离开，然后用一个简单的命令流或者是应用协议将其组合在一起，这个数据格式尽量采用文本格式，以一点点格式解析的代价，换得可以使用通用工具来构造或解读数据流的好处
4. 分离原则：策略同机制分离，接口同引擎分离。  
    > 策略的变化要远远快于机制。这条准则告诉我们应该设法将接口和引擎剥离开来。  
    实现这种剥离的一个方法是，将应用按照一个库来编写，这个库包含许多由内嵌脚本语言驱动的服务程序，整个应用的控制流程则用脚本来撰写  
    另一个方法是将应用程序分成可以协作的前端和后端进程，通过套接字上层的专用应用协议进行通讯；前端实现策略，后端实现机制
5. 简洁原则：设计要简洁，复杂度能低则低。
    > 鼓励以简洁为美的软件文化  
    设法将程序系统分解为几个能够协作的小部分，并本能地抵制任何用过多噱头来粉饰程序的企图。
6. 吝啬原则：除非确无它法，不要编写庞大的程序。
7. 透明性原则：设计要可见，以便审查和调试。
    > 调试通常会占用四分之三甚至更多的开发时间  
    一个特别有效的减少调试工作量的方法就是设计时充分考虑透明性和显见性。  
    透明性是指一眼就能够看出软件是在做什么以及怎样做的,显见性指程序带有监视和显示内部状态的功能  
    调试选项的设置应该在设计之初便考虑进去  
    应该使用足够简单的输入输出格式，这样才能很容易地检验有效输入和正确输出之间的关系是否正确。  
    还应该提倡接口简洁，以方便其它程序对其进行操作——尤其是测试监视工具和调试脚本  
8. 健壮原则：健壮源于透明与简洁。
    > 健壮性指软件不仅能在正常情况下运行良好，而且在超出设计者设想的意外条件下也能够运行良好。  
    让程序健壮的方法，就是让程序的内部逻辑更易于理解,要做到这一点主要有两种方法：透明化和简洁化。程序越简洁，越透明，也就越健壮。  
    在有异常输入的情况下，保证软件健壮性的一个相当重要的策略就是避免在代码中出现特例  
    模块性（代码简朴，接口简洁）是组织程序以达到更简洁目的的一个方法。 
9. 表示原则：把知识叠入数据以求逻辑质朴而健壮。
    > 数据比代码更容易让人类理解。在设计中，应该主动将代码的复杂度转移到数据之中去。  
10. 通俗原则：接口设计避免标新立异。
    > 也叫 “最少惊奇原则”​  
    最易用的程序就是用户需要学习新东西最少的程序    
    设计接口的时候，尽量按照用户最可能熟悉的同样功能接口和相似应用程序来进行建模    
    关注目标受众。关注传统惯例。    
    最小立异原则的另一面是表象相似而实际却略有不同，这会极端危险
11. 缄默原则：如果一个程序没什么好说的，就沉默。
12. 补救原则：出现异常时，马上退出并给出足够错误信息。
13. 经济原则：宁花机器一分，不花程序员一秒。
    > 选择开发效率更高的编程语言和工具，节约程序员时间
14. 生成原则：避免手工hack，尽量编写程序去生成程序。
    > 对于代码生成器来说，需要手写的重复而麻木的高级语言代码，与机器码一样是可以批量生产的。当代码生成器能够提升抽象度时——即当生成器的说明性语句要比生成码简单时，使用代码生成器会很合算，而生成代码后就根本无需再费力地去手工处理了。  
    在 Unix 传统中，人们大量使用代码生成器使易于出错的细节工作自动化。Parser/Lexer 生成器就是其中的经典例子，而 makefile 生成器和 GUI 界面式的构建器(interface builder)则是新一代的例子。 
15. 优化原则：雕琢前先要有原型，跑之前先学会走。
    > 先制作原型，再精雕细琢。优化之前先确保能用。
16. 多样原则：决不相信所谓“不二法门”的断言。
    > Unix奉行的是广泛采用多种语言、开放的可扩展系统和用户定制机制。
17. 扩展原则：设计着眼未来，未来总比预想来得快。
    > 要为数据格式和代码留下扩展的空间  
    设计协议或是文件格式时，应使其具有充分的自描述性以便可以扩展。
    设计代码时，要有很好的组织，让将来的开发者增加新功能时无需拆毁或重建整个架构。

### Unix哲学之一言以蔽之

所有的Unix哲学浓缩为一条铁律: KISS(Keep It Simple, Stupid!)

### 应用Unix哲学

- 只要可行，一切都应该做成与来源和目标无关的过滤器。
- 数据流应尽可能文本化（这样可以使用标准工具来查看和过滤）​。
- 数据库部署和应用协议应尽可能文本化（让人可以阅读和编辑）​。
- 复杂的前端（用户界面）和后端应该泾渭分明。
- 如果可能，用C编写前，先用解释性语言搭建原型。
- 当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好。
- 宽收严发（对接收的东西要包容，对输出的东西要严格）​。
- 过滤时，不需要丢弃的信息决不丢。
- 小就是美。在确保完成任务的基础上，程序功能尽可能少。

### 运用Unix哲学的态度

如果不能确定什么是对的，那么就只做最少量的工作，确保任务完成就行，至少直到明白什么是对的。

要良好的运用Unix哲学，你就应该不断追求卓越。你必须相信，软件设计是一门技艺，值得你付出所有的智慧、创造力和激情

要良好地运用Unix哲学，你应该珍惜你的时间决不浪费。一旦某人已经解决了某个问题，就直接拿来利用，不要让骄傲或偏见拽住你又去重做一遍。永远不要蛮干；要多用巧劲，省下力气到需要的时候再用，好钢用在刀刃上。善用工具，尽可能将一切都自动化。