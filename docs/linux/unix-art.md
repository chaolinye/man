# Unix 编程艺术

## 哲学

Unix有它自己的文化；有独特的编程艺术；有一套影响深远的设计哲学。理解这些传统，会使你写出更好的软件，即使你是在非 Unix 平台上开发。

### Unix 之失

Unix文件在字节层次以上再无结构可言。文件删除了就没法恢复。Unix的安全模型公认地太过原始。作业控制有欠精致。命名方式非常混乱。或许拥有文件系统本身就是一个错误。

Unix最持久的异议恰恰来自Unix哲学的一个特性，这一条特性是Xwindow设计者首先明确提出的。X致力于提供一套 **“机制，而不是策略”​**，以支持一套极端通用的图形操作，从而把使用工具箱和界面的“观感”​（策略）推后到应用层。Unix其它系统级的服务也有类似的倾向：行为的最终逻辑被尽可能推后到使用端。

这个“错误”换来至关重要的优势：策略相对短寿，而机制才会长存。

### Unix 之得

- 开源软件    
    自由共享代码，随源代码发布就是 Unix 的文化特色
- 跨平台可移植性和开放标准   
    Unix API 是 “可移植操作系统标准”(Portable Operating System Standard) 的事实标准，因此，POS很快就被大家加了后缀变成了“POSIX”​[缩写为 POSIX 是为了读音更像 Unix]​
- Internet和万维网
    Unix对于TCP/IP的实现相对于其它系统更加稳固可靠
- 开源社区   
    由于代码共享，Unix 社区一直在吸纳最优秀的人才
- 从头到脚的灵活性   
    自诩比Unix现代和界面友好的操作系统，都有着脆弱狭隘难用的编程接口。在这样的操作系统中，完成设计者（指操作系统）预见的任务很容易，但如果要完成设计者没有预料到的任务，用户不是无计可施就是痛苦不堪。    
    相反，Unix具有非常彻底的灵活性。Unix提供众多的程序粘合手段，这意味着Unix基本工具箱的各种组件连纵开合后，将收到单个工具设计者无法想象的功效。Unix传统将重点放在尽力使各个程序接口相对小巧、简洁和正交——这也是另一个提高灵活性的方面。整个Unix系统，容易的事还是那么容易，困难的事呢，至少是有可能做到的。
- Unix Hack 之趣
    对于程序员和开发人员来说，如果完成某项任务所需要付出的努力对他们是个挑战却又恰好还在力所能及的范围内，他们就会觉得很有乐趣。因此，趣味性是一个峰值效率的标志    
    在 Unix 世界里，操作系统以成就感而不是挫折感来回报人们的努力。Unix 下的程序员通常会把Unix当作一个积极有效的帮手，而不是把操作系统当作一个对手还非得用蛮力逼迫它干活。
- Unix的经验别处也可适用

### Unix 哲学基础

Unix哲学起源于Ken Thompson早期关于如何设计一个服务接口简洁、小巧精干的操作系统的思考，

Unix管道的发明人、Unix传统的奠基人之一 Doug McIlroy 的 Unix 哲学：

- 让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。
- 假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏格式和二进制格式输入。不要坚持使用交互式输入。
- 尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是在几星期内。对拙劣的代码别犹豫，扔掉重写。
- 优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事，必先利其器。

总结：Unix哲学是这样的：一个程序只做一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。

最伟大的C语言大师之一，Rob Pike 的 Unix 哲学：

原则1：你无法断定程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已经证实那儿就是瓶颈所在。  
原则2：估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度。  
原则3：花哨的算法在n 很小时通常很慢，而n通常很小。花哨算法的常数复杂度很大。除非你确定n总是很大，否则不要用花哨算法（即使n很大，也优先考虑原则2）​。  
原则4：花哨的算法比简单算法更容易出bug、更难实现。尽量使用简单的算法配合简单的数据结构。(**拿不准就穷举**)   
原则5：数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法  
原则6：没有原则6。

Unix 哲学可以概括为：

1. 模块原则：使用简洁的接口拼合简单的部件。   
    > 计算机编程的本质就是控制复杂度。   
    要编制复杂软件而又不至于一败涂地的唯一方法就是降低其整体复杂度——用清晰的接口把若干简单的模块组合成一个复杂软件如此一来，多数问题只会局限于某个局部，那么就还有希望对局部进行改进而不至牵动全身。
2. 清晰原则：清晰胜于机巧。  
    > 维护如此重要而成本如此高昂；在写程序时，要想到你不是写给执行代码的计算机看的，而是给将来阅读维护源码的人（包括你自己）看的。   
    为了取得程序一丁点的性能提升就大幅度增加技术的复杂性和晦涩性，这个买卖做不得。  
    永远不要去吃力地解读一段晦涩的代码三次，第二次就应该加注释
3. 组合原则：设计时考虑拼接组合。
    > 在输入输出方面，Unix传统极力提倡采用简单、文本化、面向流、设备无关的格式  
    在经典的Unix下，多数程序都尽可能采用简单过滤器的形式，即将一个输入的简单文本流处理为一个简单的文本流输出。  
    根据经验如果程序不采用简单的文本输入输出流，往往极难衔接。  
    GUI场景要把复杂的交互程序跟干粗活的算法程序分离开，然后用一个简单的命令流或者是应用协议将其组合在一起，这个数据格式尽量采用文本格式，以一点点格式解析的代价，换得可以使用通用工具来构造或解读数据流的好处
4. 分离原则：策略同机制分离，接口同引擎分离。  
    > 策略的变化要远远快于机制。这条准则告诉我们应该设法将接口和引擎剥离开来。  
    实现这种剥离的一个方法是，将应用按照一个库来编写，这个库包含许多由内嵌脚本语言驱动的服务程序，整个应用的控制流程则用脚本来撰写  
    另一个方法是将应用程序分成可以协作的前端和后端进程，通过套接字上层的专用应用协议进行通讯；前端实现策略，后端实现机制
5. 简洁原则：设计要简洁，复杂度能低则低。
    > 鼓励以简洁为美的软件文化  
    设法将程序系统分解为几个能够协作的小部分，并本能地抵制任何用过多噱头来粉饰程序的企图。
6. 吝啬原则：除非确无它法，不要编写庞大的程序。
7. 透明性原则：设计要可见，以便审查和调试。
8. 健壮原则：健壮源于透明与简洁。
9. 表示原则：把知识叠入数据以求逻辑质朴而健壮。
10. 通俗原则：接口设计避免标新立异。
11. 缄默原则：如果一个程序没什么好说的，就沉默。
12. 补救原则：出现异常时，马上退出并给出足够错误信息。
13. 经济原则：宁花机器一分，不花程序员一秒。
14. 生成原则：避免手工hack，尽量编写程序去生成程序。
15. 优化原则：雕琢前先要有原型，跑之前先学会走。
16. 多样原则：决不相信所谓“不二法门”的断言。
17. 扩展原则：设计着眼未来，未来总比预想来得快。