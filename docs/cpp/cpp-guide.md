# C++ 编程指南

## 函数返回大对象应该使用输出参数还是返回值？

对于内置类型(int) 对象的返回，直接使用返回值即可

可以大对象的返回，如果满足 [RVO/NRVO](https://mp.weixin.qq.com/s/LwnDtK6HNZo_StIxQ5yJhA) 优化条件的，可以使用返回值；但是这些优化依赖于编译器，具有不确定性，`建议还是使用输出参数`

## 合理选择值类型、智能指针、裸指针、引用

总结：

- 表达所有权时优先使用值类型 `T`，其次 `unique_ptr<T>`，尽量不要使用 `shared_ptr<T>`(rust 语言甚至定死原则：一个值只有一个拥有者)
- 不需要所有权。读时用 `const T&`，写时用 `T&`，尽量不要使用裸指针 `const T*` 或者 `T*`(rust 语言不提供指针)。

通用原则：

- 使用值类型 `T` 或 `unique_ptr<T>` 来表达独占所有权
- 如果需要转移所有权，应使用智能指针，而不是使用 `T*` 或 `T&` 作为参数
- 原生指针 `T*` 和引用 `T&` 不表达所有权概念
- 不涉及所有权转移的场景，应优先使用 `T*` 或 `T&` 作为参数，而不是智能指针。例如：不应使用 `const unique_ptr<T>&` 类型作为参数
- 当函数的返回类型为 `T*` 时，应当表示一个位置，而非传递所有权。返回的指针所指向的对象必须在调用者的作用域有效。如果返回值不可能为空，则优先返回引用

智能指针：

- 使用 `shared_ptr<T>` 来表达共享所有权。如果资源只有一个所有者，应使用 `unique_ptr<T>` 而不是 `shared_ptr<T>`
- 使用 `shared_ptr` 或者 `unique_ptr` 代替 `auto_ptr`。`auto_ptr` 在 C++11 中已标识为 deprecated，在 C++17 中已去除
- 使用 `unique_ptr<T>` 作为函数的参数和返回值，代表所有权转移

参数传递:

- 使用 `T&&` 或者 `unique_ptr<T>` 类型作为参数，代表这个资源的所有权是从外部移动进来的
- 使用 `T` 类型做为参数，代表这个函数内部拥有资源的所有权，资源可能是拷贝或者移动进来的
- 使用 `unique_ptr<T>&` 类型作为参数，代表这个函数可能重置这个 `unqiue_ptr` 的指向
- 使用 `shared_ptr<T>` 类型作为参数，代表这个函数也是这个资源的其中一个拥有着
- 使用 `shared_ptr<T>&` 类型作为参数，代表这个函数可能重置这个 `shared_ptr` 的指向
- 使用 `const T&` 类型作为参数，代表这个函数对资源是只读的，且不管理资源的释放
- 使用 `T&` 类型作为参数，代表这个函数对资源可读可写，且不管理资源的释放
- 使用 `const T*` 类型作为参数，代表这个参数可能为空，这个函数对资源是只读的，其不管理资源的释放
- 使用 `T*` 类型作为参数，代表这个参数可能为空，这个函数对资源可读写

## Reference

- [Google开源项目风格指南](https://mp.weixin.qq.com/s/LwnDtK6HNZo_StIxQ5yJhA)