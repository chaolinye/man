# Effective C++

## 让自己习惯 C++

### Item 1: 视 C++ 为一个语言联邦

C++ 是一个多重范型编程语言：过程形式、面向对象形式、函数形式、泛型形式、元编程形式。

- C++ 高效编程守则视状况而变化，取决于你使用 C++ 的哪一部分

### Item 2: 尽量以 const, enum, inline 替换 #define

- 对于单纯常量，最好以 `const` 对象或 `enums` 替换 `#define`
- 对于形似函数的宏（`macros`），最好改用 `inline` 函数替换 `#define`

### Item 3: 尽可能使用 const

- 将某些东西声明为 `const` 可帮助编译器侦测出错误用法。`const` 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体
- 编译器强制实施 `bitwise constness`, 但你编写程序时应该使用 "概念上的常量性"（conceptual constness）
- 当 `const` 和 `non-const` 成员函数有着实质等价的实现时，令 `non-const` 版本调用 `const` 版本可避免代码重复

### Item 4: 确定对象被使用前已先被初始化

- 为内置型对象进行手工初始化，因为 C++ 不保证初始化它们
- 构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序相同。
- 为免除 "跨编译单元之初始化次序" 问题，请以 `local static` 对象替换 `non-local static` 对象。

## 构造/析构/赋值运算

### Item 5: 了解 C++ 默默编写并调用哪些函数

- 编译器可以暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符，以及析构函数

### Item 6: 若不想使用编译器自动生成的函数，就该明确拒绝

- 为驳回编译器自动提供的机能，可将相应的成员函数声明为 private 并且不予实现。使用像 Uncopyable 这样的 base class 也是一种做法

### Item 7：为多态基类声明 virtual 析构函数

- 基类应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数
- Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性，就不该声明 virtual 析构函数

### Item 8: 别让异常逃离析构函数

- 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序
- 如果客户端需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数）执行该操作。

### Item 9: 绝不在构造和析构过程中调用 virtual 函数

- 在构造和析构期间不要调用 `virtual` 函数，因为这类调用从不下降至 `derived class`（比起当前执行构造函数和析构函数的那层） 

### Item 10: 令 operator= 返回一个 reference to *this

### Item 11: 在 operator= 中处理 "自我赋值"

- 确保当对象自我赋值时 `operator=` 有良好行为。其中技术包括比较"来源对象"和"目标对象"的地址、精心周到的语句顺序、以及 `copy-and-swap`
- 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确

### Item 12: 复制对象时勿忘其每一个成分

- Copying 函数应该确保复制 "对象内的所有成员变量" 及 "所有 base class 成分"
- 不要尝试以某个 copying 函数实现另一个 copying 函数。应该将共同机能放进第三个函数中，并由两个 coping 函数共同调用。

## 资源管理

### Item 13: 以对象管理资源

- 为防止资源泄漏，请使用 `RAII`(资源取得时机便是初始化时机)，它们在构造函数中获得资源并在析构函数中释放资源
- 两个常被使用的 RAII classes 分别时 `tr1:shared_ptr` 和 `auth_ptr`。前者通常时较佳选择，因为其 copy 行为比较直观。若选择 auto_ptr, 复制动作会使它（被复制物）指向 null

> RAII 守则：资源在构造期间获得，在析构期间释放

### Item 14: 在资源管理类中小心 coping 行为

- 复制 RAII 对象必须一并复制它所管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为
- 普遍而常见的 RAII class copying 行为是：抑制 copying、施行引用计数法（reference counting）。不过其他行为也都可能被实现

### Item 15: 在资源管理类中提供对原始资源的访问

- API 往往要求访问原始资源，所以每一个 RAII class 应该提供一个 "取得其管理之资源" 的方法
- 对原始资源的访问可能经由显示转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便

### Item 16: 成对使用 new 和 delete 时要采取相同形式

- 如果你在 `new` 表达式中使用 `[]`, 必须在相应的 `delete` 表达式中也使用 `[]`。如果你在 `new` 表达式中不使用 `[]`, 一定不要再相应的 `delete` 表达式中使用 `[]`

### Item 17: 以独立语句将 newed 对象置入智能指针

- 以独立语句将 newed 对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏

## 设计与声明

### Item 18: 让接口容易被正确使用，不易被误用

- 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质
- "促进正确使用" 的方法包含接口的一致性，以及与内置类型的行为兼容
- "阻止误用" 的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任
- `tr1::shared_ptr` 支持定制型删除器。这可防范 DLL 问题，可被用来自动解除互斥锁等等

### Item 19: 设计 class 犹如设计 type

- 新 type 的对象应该如何被创建和销毁？
- 对象的初始化和对象的赋值该由什么样的差别？
- 新 type 的对象如果被 passed by value，意味着什么？
- 什么是新 type 的 合法值？
- 你的新 type 需要配置某个继承图系吗？
- 你的新 type 需要什么样的转换？
- 什么样的操作符和函数对此新 type 而言是合理的？
- 什么样的标准函数应该驳回？
- 谁该取用新的 type 的成员？
- 什么是新 type 的 “未声明接口”？
- 你的新 type 有多么一般化？
- 你真的需要一个新 type 吗？

### Item 20: 宁以 pass-by-reference-to-const 替换 pass-by-value

- 尽量以 `pass-by-reference-to-const` 替换 `pass-by-value`。前者通常比较高效，并可避免切割问题。
- 以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对它们而言，pass-by-value 往往比较适当

### Item 21: 必须返回对象时，别妄想返回其 reference

- 绝不要返回 pointer 或者 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象


### Item 22: 将成员变量声明为 private

- 切记将成员变量声明为 private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供 class 作者以充分的实现弹性
- protected 并不比 public 更具封装性

### Item 23: 宁以 non-member、non-friend 替换 member 函数

- 宁可拿 non-member non-friend 函数替换 member 函数。这样做可以增加封装性、包裹弹性（packaging flexibility） 和机能扩充性

### Item 24: 若所有参数皆需类型转换，请为此采用 non-member 函数

- 如果你需要为某个函数的所有参数（包括被 this 指针所指的那个隐喻参数）进行类型转换，那么这个函数必须要是个 non-member

### Item 25: 考虑写出一个不抛异常的 swap 函数

- 当 `std::swap` 对你的类型效率不高时，提供一个 `swap` 成员函数，并确定这个函数不抛出异常.
- 如果你提供一个 `member swap`，也该提供一个 `non-member swap` 用来调用前者。对于 classes（而非 templates），也请特化 `std::swap`
- 调用 `swap` 时应针对 `std::swap` 使用 using 声明式，然后调用 swap 并且不带任何"命名空间资格修饰"
- 为 "用户定义类型" 进行 std templates 全特化是好的，但千万不要尝试在 std 内加入某些对 std 而言全新的东西

## 实现

### Item 26：尽可能延后变量定义式的出现时间

- 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。

> 对于循环变量，也尽量使用循环内定义，除非效率高度敏感

### Item 27: 尽量少做转型动作

- 如果可以，尽量避免转型，特别式在注重效率的代码中避免 `dynamic_casts`。如果有个设计需要转型动作，试着发展无需转型的替代设计。
- 如果转型式必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。
- 宁可使用 C++ style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。

### Item 28: 避免返回 handles 指向对象内部成分

- 避免返回 handles（包括 references、指针、迭代器）指向对象内部。遵守这个条款可以增加封装性，帮助 const 成员函数的行为像个 const，并将发生 "虚吊号码牌"（dangling handles）的可能性降至最低。

### Item 29：为 "异常安全" 而努力式值得的

- 异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。
- “强烈保证” 往往能够以 `copy-and-swap` 实现出来，但 "强烈保证" 并非对所有函数都可实现或具备现实意义。
- 函数提供的 "异常安全保证" 通常最高只等于其所调用之各个函数的 “异常安全保证” 中的最弱者。

### Item 30: 透彻了解 inlining 的里里外外

- 将大多数 inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。
- 不要只因为 function templates 出现在头文件，就将它们声明为 inline

### Item 31: 将文件间的编译依存关系降至最低

- 支持 "编译依存性最小化" 的一般构想使：相依于声明式，不要相依于定义式。基于此构想的两个手段式 `Handle classes` 和 `Interface classes`
- 程序库头文件应该以 "完全且仅有声明式"（full and declaration-only forms）的形式存在。这种做法不论是否涉及 templates 都适用

# 继承与面向对象设计

### Item 32: 确定你的 public 继承塑模出 is-a 关系



