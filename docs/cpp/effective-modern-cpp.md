# Effective Modern C++

## 类型推导

### Item 1: 理解模板类型推导

- 在模板类型推导时，有引用的实参会被视为无引用，他们的引用会被忽略
- 对于通用引用的推导，左值实参会被特殊对待
- 对于传值类型推导，`const`或 `volatile` 实参会被认为是 `non-const` 的和 `non-volatile` 的
- 在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用

### Item 2: 理解 auto 类型推导

- `auto` 类型推导通常和模板类型推导相同，但是 `auto` 类型推导假定花括号初始化代表 `std::initializer_list`，而模板类型推导不这样做
- 在 C++14 中 `auto` 允许出现在函数返回值或者 `lambda` 函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是 `auto` 类型推导

### Item 3: 理解 decltype

- `decltype` 总是不加修改的产生变量或者表达式的类型。
- 对于 T 类型的不是单纯的变量名的左值表达式，`decltype` 总是产出 `T` 的引用即 `T&`。
- C++14 支持 `decltype(auto)`，就像 `auto` 一样，推导出类型，但是它使用 `decltype` 的规则进行推导。

### Item 4: 学会查看类型推导结果

- 类型推断可以从 IDE 看出，从编译器报错看出，从 Boost TypeIndex 库的使用看出
- 这些工具可能既不准确也无帮助，所以理解 C++ 类型推导规则才是最重要的

## auto

### Item 5: 优先考虑 auto 而非显式类型声明

- auto 变量必须初始化，通常它可以避免一些移植性和效率性的问题，也使得重构更方便，还能让你少打几个字。
- 正如 Item 2 和 6 讨论的，auto 类型的变量可能会踩到一些陷阱。

### Item 6: auto 推导若非己愿，使用显式类型初始化惯用法

- 不可见的代理类可能会使 auto 从表达式中推导出“错误的”类型
- 显式类型初始器惯用法强制 auto 推导出你想要的结果

## 移步现代C++

### Item 7: 区别使用 () 和 {} 创建对象

- 括号初始化是最广泛使用的初始化语法，它防止变窄转换，并且对于C++最令人头疼的解析有天生的免疫性
- 在构造函数重载决议中，括号初始化尽最大可能与 `std::initializer_list` 参数匹配，即便其他构造函数看起来是更好的选择
- 对于数值类型的 `std::vector` 来说使用花括号初始化和小括号初始化会造成巨大的不同
- 在模板类选择使用小括号初始化或使用花括号初始化创建对象是一个挑战。

### Item 8: 优先考虑 nullptr 而非 0 和 NULL

- 优先考虑 `nullptr` 而非 0 和 NULL
- 避免重载指针和整型

### Item 9: 优先考虑别名声明而非 typedefs

- `typedef` 不支持模板化，但是别名声明支持。
- 别名模板避免了使用 `::type` 后缀，而且在模板中使用 `typedef` 还需要在前面加上 `typename`
- C++14 提供了 C++11 所有 `type traits` 转换的别名声明版本

### Item 10: 优先考虑限域 enum 而非未限域 enum

- C++98 的 `enum` 即非限域 `enum`。
- 限域 `enum` 的枚举名仅在 `enum` 内可见。要转换为其它类型只能使用 `cast`。
- 非限域/限域 `enum` 都支持底层类型说明语法，限域 `enum` 底层类型默认是 `int`。非限域 `enum` 没有默认底层类型。
- 限域 `enum` 总是可以前置声明。非限域 `enum` 仅当指定它们的底层类型时才能前置。

### Item 11: 优先考虑使用 deleted 函数而非使用未定义的私有声明

- 比起声明函数为 `private` 但不定义，使用 `deleted` 函数更好
- 任何函数都能被删除（be deleted），包括非成员函数和模板实例（译注：实例化的函数）

### Item 12: 使用 override 声明重写函数

- 为重写函数加上 `override`
- 成员函数引用限定让我们可以区别对待左值对象和右值对象（即 `*this`)

### Item 13: 优先考虑 const_iterator 而非 iterator

- 优先考虑 `const_iterator` 而非 `iterator`
- 在最大程度通用的代码中，优先考虑非成员函数版本的 `begin`，`end`，`rbegin`等，而非同名成员函数

### Item 14: 如果函数不抛出异常请使用 noexcept

- `noexcept` 是函数接口的一部分，这意味着调用者可能会依赖它
- `noexcept` 函数较之于 `non-noexcept` 函数更容易优化
- `noexcept` 对于移动语义，`swap`，内存释放函数和析构函数非常有用
- 大多数函数是异常中立的（译注：可能抛也可能不抛异常）而不是 `noexcept`

### Item 15: 尽可能的使用 constexpr

- `constexpr` 对象是 `const`，它被在编译期可知的值初始化
- 当传递编译期可知的值时，`constexpr` 函数可以产出编译期可知的结果
- `constexpr` 对象和函数可以使用的范围比 `non-constexpr`对象和函数要大
- `constexpr` 是对象和函数接口的一部分

### Item 16: 让 const 成员函数线程安全

- 确保 `const` 成员函数线程安全，除非你确定它们永远不会在并发上下文（concurrent context）中使用。
- 使用 `std::atomic` 变量可能比互斥量提供更好的性能，但是它只适合操作单个变量或内存位置。

### Item 17: 理解特殊成员函数的生成

- 特殊成员函数是编译器可能自动生成的函数：默认构造函数，析构函数，拷贝操作，移动操作。
- 移动操作仅当类没有显式声明移动操作，拷贝操作，析构函数时才自动生成。
- 拷贝构造函数仅当类没有显式声明拷贝构造函数时才自动生成，并且如果用户声明了移动操作，拷贝构造就是delete。拷贝赋值运算符仅当类没有显式声明拷贝赋值运算符时才自动生成，并且如果用户声明了移动操作，拷贝赋值运算符就是delete。当用户声明了析构函数，拷贝操作的自动生成已被废弃。
- 成员函数模板不抑制特殊成员函数的生成。

## 智能指针

### Item 18: 对于独占资源使用 std::unique_ptr

- `std::unique_ptr` 是轻量级、快速的、只可移动（move-only）的管理专有所有权语义资源的智能指针
- 默认情况，资源销毁通过 `delete` 实现，但是支持自定义删除器。有状态的删除器和函数指针会增加 `std::unique_ptr` 对象的大小
- 将 `std::unique_ptr` 转化为 `std::shared_ptr` 非常简单

### Item 19: 对于共享资源使用 std::shared_ptr

- `std::shared_ptr` 为有共享所有权的任意资源提供一种自动垃圾回收的便捷方式。
- 较之于 `std::unique_ptr`，`std::shared_ptr` 对象通常大两倍，控制块会产生开销，需要原子性的引用计数修改操作。
- 默认资源销毁是通过 `delete`，但是也支持自定义删除器。删除器的类型是什么对于 `std::shared_ptr` 的类型没有影响。
- 避免从原始指针变量上创建 `std::shared_ptr`。

### Item 20: 当 std::shard_ptr 可能悬空时使用 std::weak_ptr

- 用 `std::weak_ptr` 替代可能会悬空的 `std::shared_ptr`。
- `std::weak_ptr` 的潜在使用场景包括：缓存、观察者列表、打破 `std::shared_ptr` 环状结构。

### Item 21: 优先考虑使用 std::make_unique 和 std::make_shared 而非 new

- 和直接使用 `new` 相比，`make` 函数消除了代码重复，提高了异常安全性。对于 `std::make_shared` 和 `std::allocate_shared`，生成的代码更小更快。
- 不适合使用 `make` 函数的情况包括需要指定自定义删除器和希望用花括号初始化。
- 对于 `std::shared_ptrs`，其他不建议使用 `make` 函数的情况包括   
    (1)有自定义内存管理的类；   
    (2)特别关注内存的系统，非常大的对象，以及 `std::weak_ptrs` 比对应的 `std::shared_ptrs`活得更久。

### Item 22: 当使用 Pimpl 惯用法，请在实现文件中定义特殊成员函数

- `Pimpl` 惯用法通过减少在类实现和类使用者之间的编译依赖来减少编译时间。
- 对于 `std::unique_ptr` 类型的 `pImpl` 指针，需要在头文件的类里声明特殊的成员函数，但是在实现文件里面来实现他们。即使是编译器自动生成的代码可以工作，也要这么做。
- 以上的建议只适用于 `std::unique_ptr`，不适用于 `std::shared_ptr`。

## 右值引用，移动语义，完美转发

### Item 23: 理解 std::move 和 std::forward

- `std::move` 执行到右值的无条件的转换，但就自身而言，它不移动任何东西。
- `std::forward` 只有当它的参数被绑定到一个右值时，才将参数转换为右值。
- `std::move` 和 `std::forward` 在运行期什么也不做。

### Item 24: 区分通用引用与右值引用

- 如果一个函数模板形参的类型为 `T&&`，并且T需要被推导得知，或者如果一个对象被声明为 `auto&&`，这个形参或者对象就是一个通用引用。
- 如果类型声明的形式不是标准的 `type&&`，或者如果类型推导没有发生，那么 `type&&` 代表一个右值引用。
- 通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用。

### Item 25: 对右值引用使用 std::move，对通用引用使用 std::forward

- 最后一次使用时，在右值引用上使用 `std::move`，在通用引用上使用 `std::forward`。
- 对按值返回的函数要返回的右值引用和通用引用，执行相同的操作。
- 如果局部对象可以被返回值优化消除，就绝不使用 `std::move` 或者 `std::forward`。

### Item 26: 避免在通用引用上重载

- 对通用引用形参的函数进行重载，通用引用函数的调用机会几乎总会比你期望的多得多。
- 完美转发构造函数是糟糕的实现，因为对于 `non-const` 左值，它们比拷贝构造函数而更匹配，而且会劫持派生类对于基类的拷贝和移动构造函数的调用。

### Item 27: 熟悉通用引用重载的替代方法

- 通用引用和重载的组合替代方案包括使用不同的函数名，通过 `lvalue-reference-to-const` 传递形参，按值传递形参，使用tag dispatch。
- 通过std::enable_if约束模板，允许组合通用引用和重载使用，但它也控制了编译器在哪种条件下才使用通用引用重载。
- 通用引用参数通常具有高效率的优势，但是可用性就值得斟酌。

### Item 28: 理解引用折叠

- 引用折叠发生在四种情况下：模板实例化，`auto` 类型推导，`typedef` 与别名声明的创建和使用，`decltype`。
- 当编译器在引用折叠环境中生成了引用的引用时，结果就是单个引用。有左值引用折叠结果就是左值引用，否则就是右值引用。
- 通用引用就是在特定上下文的右值引用，上下文是通过类型推导区分左值还是右值，并且发生引用折叠的那些地方。

### Item 29: 假定移动操作不存在，成本高，未被使用

- 假定移动操作不存在，成本高，未被使用。
- 在已知的类型或者支持移动语义的代码中，就不需要上面的假设。

### Item 30: 熟悉完美转发失败的情况

- 当模板类型推导失败或者推导出错误类型，完美转发会失败。
- 导致完美转发失败的实参种类有花括号初始化，作为空指针的0或者NULL，仅有声明的整型 `static const` 数据成员，模板和重载函数的名字，位域。

## lambda表达式

### Item 31: 避免使用默认捕获模式

- 默认的按引用捕获可能会导致悬空引用。
- 默认的按值捕获对于悬空指针很敏感（尤其是 this 指针），并且它会误导人产生 lambda 是独立的想法。

### Item 32: 使用初始化捕获来移动对象到闭包中

- 使用 C++14 的初始化捕获将对象移动到闭包中。
- 在 C++11 中，通过手写类或 `std::bind` 的方式来模拟初始化捕获。

### Item 33: 对 auto&& 形参使用 decltype 以 std::forward 它们

### Item 34: 优先考虑 lambda 而非 std::bind

- 与使用 `std::bind` 相比，lambda 更易读，更具表达力并且可能更高效。
- 只有在 C++11 中，`std::bind` 可能对实现移动捕获或绑定带有模板化函数调用运算符的对象时会很有用。

## 并发 API

### Item 35: 优先考虑基于任务的编程而非基于线程的编程

- `std::thread` API 不能直接访问异步执行的结果，如果执行函数有异常抛出，代码会终止执行。
- 基于线程的编程方式需要手动的线程耗尽、资源超额、负责均衡、平台适配性管理。
- 通过带有默认启动策略的 `std::async` 进行基于任务的编程方式会解决大部分问题。

### Item 36: 如果有异步的必要请指定 std::launch::async

- `std::async` 的默认启动策略是异步和同步执行兼有的。
- 这个灵活性导致访问 `thread_locals` 的不确定性，隐含了任务可能不会被执行的意思，会影响调用基于超时的 `wait` 的程序逻辑。
- 如果异步执行任务非常关键，则指定 `std::launch::async`。

### Item 37: 使 std::thread 在所有路径最后都不可结合

- 在所有路径上保证 `thread` 最终是不可结合的。
- 析构时 `join` 会导致难以调试的表现异常问题。
- 析构时 `detach` 会导致难以调试的未定义行为。
- 声明类数据成员时，最后声明 `std::thread` 对象。

### Item 38: 关注不同线程句柄的析构行为

- `future` 的正常析构行为就是销毁 `future` 本身的数据成员。
- 引用了共享状态——使用 `std::async` 启动的未延迟任务建立的那个——的最后一个 `future` 的析构函数会阻塞住，直到任务完成。

### Item 39: 对于一次性事件通信考虑使用 void 的 futures

- 对于简单的事件通信，基于条件变量的设计需要一个多余的互斥锁，对检测和反应任务的相对进度有约束，并且需要反应任务来验证事件是否已发生。
- 基于 `flag` 的设计避免的上一条的问题，但是是基于轮询，而不是阻塞。
- 条件变量和 `flag` 可以组合使用，但是产生的通信机制很不自然。
- 使用 `std::promise` 和 `future` 的方案避开了这些问题，但是这个方法使用了堆内存存储共享状态，同时有只能使用一次通信的限制。

### Item 40: 对于并发使用 std::atomic，对于特殊内存使用 volatile

- `std::atomic` 用于在不使用互斥锁情况下，来使变量被多个线程访问的情况。是用来编写并发程序的一个工具。
- `volatile` 用在读取和写入不应被优化掉的内存上。是用来处理特殊内存的一个工具。

## 微调

### 对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递

- 对于可拷贝，移动开销低，而且无条件被拷贝的形参，按值传递效率基本与按引用传递效率一致，而且易于实现，还生成更少的目标代码。
- 通过构造拷贝形参可能比通过赋值拷贝形参开销大的多。
- 按值传递会引起切片问题，所说不适合基类形参类型。

### 考虑使用置入代替插入

- 原则上，置入函数有时会比插入函数高效，并且不会更差。
- 实际上，当以下条件满足时，置入函数更快：
    - 值被构造到容器中，而不是直接赋值；
    - 传入的类型与容器的元素类型不一致；
    - 容器不拒绝已经存在的重复值。
- 置入函数可能执行插入函数拒绝的类型转换。

## References

- [Effective Modern C++](https://cntransgroup.github.io/EffectiveModernCppChinese/Introduction)