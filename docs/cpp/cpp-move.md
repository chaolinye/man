# C++ 移动语义

移动语义是现代 C++ 的重要特征之一。

## 移动语义的基本特征

### 移动语义的力量

#### 动机

移动的本质是偷取 **临时对象(未命名对象，返回值)** 或者 **明确说明（`std::move`）不再需要值的对象** 的堆内存或者资源。

移动语义允许对对象的复制进行优化，它可以隐式使用 (用于未命名的临时对象或局部返回
值)，也可以显式使用 (通过 std::move())。

在移动语义出现之前，这些对象只能复制，导致没必要的耗时.

最常见的两种可以从移动语义收益的对象：`std::string` 和 `std::vector`。

> 这意味着返回字符串向量，并将其赋值给现有向量不再有性能问题。我们可以像使用整型一样使用字符串向量，从而获得更好的性能。这样，大部分情况下可以直接使用返回值了，不再需要别扭的输出参数了（输出参数大部分情况下性能还是更优，但差距不大，考虑可读性，可以优先选择返回值）。

老版本的 C++ 代码使用具有移动语义的 C++11 编译器重新编译，无需修改代码，即可获得 10% 到 40% 的提速(取决于现有代码的难易程度)。

> 获得优化的原因使：编译器会自动完成临时对象和返回值的移动；如果需要进一步优化，需要在代码中合适的地方使用 `std::move`

#### 移动的实现

一个对象的移动，是通过所属类的移动构造函数或者移动赋值函数实现的

> `std::string` 和 `std::vector` 等标准库类已经实现了

> std::move() 表示不再需要这个值，它将对象标记为可移动的。标记为 std::move() 的对象不会 (部分地) 销毁 (析构函数仍然会调用)。

移动的 C++ 标准库的对象仍然是有效的对象，但其值为未定义。

#### 复制是一种应急方式

如果类没有实现这些移动函数，也会降级使用复制构造函数或者复制赋值函数，因此能做到向后兼容性

#### const 对象的移动语义

不能移动用 const 声明的对象

const 对象的 std::move() 没起作用

> const 对象不允许修改，自然也不允许被窃取内容，即不能移动

!> 因此，从 C++11 开始，用 const 返回值就不再是好的方式了

!> 如果按值 (而不是按引用) 返回，不要将返回值声明为 const。仅在声明引用或者指针返回类型时使用 const

### 移动语义的核心

#### 右值引用

> 右值引用使用 && 声明，没有 const。
> 右值引用延长了由返回值的对象的生命周期。


#### std::move

std::move() 对应的是右值引用类型的 static_cast。这允许我们将命名对象传递给右值引用。

std::move() 标记的对象也可以通过 const 左值引用，传递给接受实参但不接受非 const 左值引用的函数。

#### 移动的对象

已移动的对象处于有效但未定义的状态，C++ 标准库为其类型保证了这一点。您仍然可以(重新) 使用它们，只要您不对它们的价值做任何期望。

#### 通过引用进行重载

> const 右值引用是可能的，但针对它们的实现通常没有意义。

#### 按值传递

标记为 std::move() 的对象也可以传递给按值接受参数的函数。在这种情况下，移动语义用于初始化参数，这可以使按值调用非常高效。

### 类中的移动语义

### 如何从移动语义中获益

### 引用的重载

### 已移动状态

### 值的种类

## 泛型代码中的移动语义

## C++ 标准库中的移动语义